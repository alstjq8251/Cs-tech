### 디자인 패턴이란?
- 디자인 패턴이란 기존 환경 내에서 반복적으로 일어나는 문제들을 어떻게 풀어나갈 것인가에 대한 솔루션 같은 것이다.

#### 디자인 패턴의 개념
- 소프트웨어 공학의 소프트웨어 설계에서 공통으로 발생하는 문제에 대해 자주 쓰이는 설계 방법을 정리한 패턴을 말한다.
- 디자인 패턴을 참고해 개발할 경우 개발 효율성 , 유지보수성 ,  운용성등의 품질이 높아지며 프로그램 최적화에 도움이 된다.

#### 디자인 패턴이 등장하게 된 배경
1. 객체지향 설계의 어려움
  - 객체지향 설계를 잘하는 것은 쉽지 않으며 그것들을 재사용 할 수 있게 만드는 것은 더욱 어렵다.
  - 요구사항을 최대한 만족하고 있어야 하며 향후 생길 수 있는 문제들을 수용할 수 있도록 일반적이며 포괄적으로 설계해야 하기 때문이다.
2. 반복적인 문제의 등장
  -  객체지향 프로그래밍에선 초기 설계를 할 수 있게 도와주는 SOLID 원칙 , 소프트웨어 방법론등이 존재하지만 설계 , 개발을 진행하면 할수록

     반복적인 문제를 맞닥뜨리게 되며 공통으로 만나는 문제들을 일반화 , 패턴화 시켜 사용할 필요가 존재했다.
 
 디자인 패턴의 효용성
 ```
 디자인 패턴은 재사용이 가능한 설계를 지향하며 재사용을 방해하는 설계는 배제하도록 만들어준다. 
 디자인 패턴은 이미 만들어진 시스템의 유지보수 및 문서화 되어있는 것들을 개선하도록 도와준다.
 디자인 패턴은 클레스 간 명세 , 객체 각 유기적인 관계 , 의존성 , 설계 의도 또한 명확하게 정의하도록 도와준다.
 ```
 
 > 디자인 패턴은 설계자들이 올바른 설계를 빨리 할 수 있도록 만들어진 방법들이라 할 수 있다.

#### 디자인 패턴의 구성 요소
| 구성요소 | 설명 | 
| :--: | :--: | 
| 패턴의 이름 | 디자인 패턴을 부를때 사용하는 이름과 디자인 패턴의 유형 |
| 문제 및 배경 | 디자인 패턴이 사용되는 분야 또는 배경, 해결하는 문제를 의미|
| 솔루션 | 디자인 패턴을 이루는 요소들 , 관계, 협동 과정|
| 사례 | 디자인 패턴의 간단한 적용 사례 |
| 결과 | 디자인 패턴을 사용하면 얻게 되는 이점이나 영향 |
| 샘플 코드 | 디자인 패턴이 적용된 원시 코드 |

#### 디자인 패턴의 유형
| 구분 | 유형 | 설명
| :--: | :--: | :--: |
| 목적| 생성 | 객체 인스턴스 생성에 관여 , 클래스 정의와 객체 생성 방식을 구조화 , 캡슐화를 수행하는 패턴|
| 목적| 구조 | 더 큰 구조 형성 목적으로 클래스나 객체의 조합을 다루는 패턴
| 목적| 행위 | 클래스나 객체들이 상호작용하는 방법과 역할 분담을 다루는 패턴
 범위 | 클래스 | 클래스 관 관련성(상속 관계를 다루는 패턴) , `컴파일 타임`에 정적으로 결정
 범위 | 객체 | 객체 간 관련성을 다루는 패턴 , `런타임`에 동적으로 결정|
 
 #### 디자인 패턴의 종류
| 생성(Creational) 패턴 | 구조(Structural) 패턴 | 행동(Behavioral) 패턴|
| :--: | :--: | :--: |
| `Builder` | `Bridge` | `Interpreter`|
| `Prototype` | `Decorator` | `Template Method`|
| `Factory Method` | `Facade` | `Chain of Responsibility`|
| `Abstract Factory` | `Flyweight` | `Command`|
| `Singleton`| `Proxy`| `Iterator`|
|    | `Composite` | `Mediator`|
|    | `Adaptor` | `Memonto`|
|    |    |  `Observer`|
|   |     | `State`|
|   |     | `Strategy`|
|    |    | `Visitor`|

#### 각 패턴별 설명
| 구분 | 패턴 | 설명|
|:--: | :--: | :--:|
| 생성 패턴 | `Builder` | 생성 단계를 캡슐화하여 구축 공정을 동일하게 이용하도록 하는 패턴
| 생성 패턴 | `Prototype` | 복사하여 새 객체를 생성할 수 있도록 하는 패턴
| 생성 패턴 | `Factory Method` | 객체를 생성하기 위한 인터페이스를 정의하여 어떤 클래스가 인스턴스화 될 것인지는<br> 서브 클래스가 결정하도록 하는 패턴|
| 생성 패턴 | `Abstract Factory` | 생성군들을 하나에 모아놓고 팩토리 중에서 선택하게 하는 패턴
| 생성 패턴 | `Singleton` | 유일한 하나의 인스턴스를 보장하도록 하는 패턴
| 구조 패턴 | `Bridge` | 추상과 구현을 분리하여 결합도를 낮춘 패턴
| 구조 패턴 | `Decorator` | 소스를 변경하지 않고 기능을 확장하도록 하는 패턴
| 구조 패턴 | `Facade`| 하나의 인터페이스를 통해 느슨한 결합을 제공하는 패턴
| 구조 패턴 | `Flyweight` | 대량의 작은 객체들을 공유하는 패턴
| 구조 패턴 | `Proxy` | 대리인이 대신 그 일을 처리하는 패턴
| 구조 패턴 | `Composite` | 개별 객체와 복합 객체를 클라이언트에서 동일하게 사용하도록 하는 패턴
| 구조 패턴 | `Adaptor` | 인터페이스로 인해 함께 사용하지 못하는 클래스를 함게 사용하도록 하는 패턴
| 행위 패턴 | `Interpreter` | 언어 규칙 클래스를 이용하는 패턴
| 행위 패턴 | `Template Method` | 알고리즘 골격의 구조를 정의한 패턴
| 행위 패턴 | `Chain of Responsibility` | 객체들끼리 연결 고리를 만들어 내부적으로 전달하는 패턴
| 행위 패턴 | `Command` | 요청 자체를 캡슐화하여 파라미터로 넘기는 패턴
| 행위 패턴 | `Iterator` | 내부 표현은 보여주지 않고 순회하는 패턴
| 행위 패턴 | `Mediator` | 객체 간 상호작용을 캡슐화한 패턴
| 행위 패턴 | `Memonto` | 상태 값을 미리 저장해 두었다가 복구하는 패턴
| 행위 패턴 | `Observer` | 상태가 변할 때 의존자들에게 알리고 자동 업데이트 하는 패턴
| 행위 패턴 | `State` | 객체 내부 상태에 따라서 행위를 변경하는 패턴
| 행위 패턴 | `Strategy` | 다양한 알고리즘을 캡슐화하여 알고리즘 대체가 가능하도록 한 패턴
| 행위 패턴 | `Visitor` | 오퍼레이션을 별도의 클래스에 새롭게 정의한 패턴

#### 디자인 패턴의 장단점
1. 장점
  - 요구사항 변경에 다른 소스 코드 변경을 최소화 할 수 있게 해준다
  - 설계 변경 요청에 따른 유연한 대처가 가능하다.
  - 범용적인 코딩 스타일이 적용 가능해진다.
  - 개발자 간의 원활한 의사소통이 가능해진다.
  - 재사용을 통한 개발 시간 단축이 가능해진다.
  - 소프트웨어 구조를 파악하기 용이해진다.
  - 객체지향 설계 및 구현의 생산성을 높이는 데 적합하다.
2. 단점
  - 객체지향 설계/구현 위주로 사용한다.
  - 초기 투자 비용의 부담이 커진다.
 

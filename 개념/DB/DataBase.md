## Database
`정의`
  - 여러 사람에 의해 **공동으로 사용될 데이터를 중복을 배제하여 통합하고,** 쉽게 접근하여 처리할 수 있도록 **저장장치에**

    **저장하여 항상 사용 할 수 있도록 운영하는 운영 데이터**이다.
    
`구분`
  - 통합된 데이터(Integrated Data)
    - 자료의 중복을 배제한 데이터의 모임
  - 저장된 데이터(Stored Data) 
    - 컴퓨터가 접근할 수 있는 저장 매체에 저장한 자료
  - 운영 데이터(Operational Data)
    - 조직의 고유한 업무를 수행하는 데 반드시 필요한 자료
  - 공용 데이터(Shared Data)
    - 여러 응용 시스템들이 공동으로 소유하고 유지하는 자료

### DBMS
`정의`
  - **사용자의 요구에 따라 정보를 생성해주고, 데이터베이스를 관리해주는 소프트웨어**이다.
  - 기존의 파일 시스템이 갖는 데이터의 종속성과 중복성의 문제를 해결하기 위해 제안된 시스템이다.

`필수 기능 3가지`
1. 정의(Definition) 기능
   - 데이터의 형(Type)과 구조에 대한 정의, 이용 방식, 제약 조건 등을 명시하는 기능
2. 조작(Manipulation) 기능
   - 데이터 검색, 갱신, 삽입, 삭제 등을 위해 인터페이스 수단을 제공하는 기능
3. 제어(Control) 기능
   - 데이터의 무결성, 보안, 권한 검사, 병행 제어를 제공하는 기능
     
### DB 설계
  - 사용자의 요구를 분석해 그것들을 컴퓨터에 저장할 수 있는 데이터베이스의 구조에 맞게 변형한 후 DBMS로 데이터베이스를 구현하여 

    일반 사용자들이 사용하게 하는 것 이다.
    
`고려 사항`

| 항목 | 내용 |
| :--: | :--: |
| 무결성 | 삽입, 삭제, 갱신 등의 연산 후에도 데이터베이스에 저장된 데이터가 정해진 제약 조건을 항상 만족해야 함 |
| 일관성 | 데이터베이스에 저장된 데이터들 사이나, 특정 질의에 대한 응답이 처음부터 끝까지 변함없이 일정해야 함 |
| 회복 | 시스템에 장애가 발생했을 때 장애 발생 직전의 상태로 복구할 수 있어야 함 |
| 보안 | 불법적인 데이터의 노출 또는 변경이나 손실로부터 보호할 수 있어야 함 |
| 효율성 | 응답시간의 단축, 시스템의 생산성, 저장 공간의 최적화 등이 가능해야 함 |
| 데이터베이스 확장 | 데이터베이스 운영에 영향을 주지 않으면서 지속적으로 데이터를 추가할 수 있어야 함 |

`설계 순서`
1. 요구 조건 분석 - 요구 조건 명세서 작성
2. 개념적 설계 - 개념 스키마, 트랜잭션 모델링, E-R 모델
3. 논리적 설계 - 목표 DBMS에 맞는 논리 스키마 설계, 트랜잭션 인터페이스 설계
4. 물리적 설계 - 목표 DBMS에 맞는 물리적 구조의 데이터로 변환
5. 구현 - 목표 DBMS의 DDL(데이터 정의어)로 데이터베이스 생성, 트랜잭션 작성

#### DB 이중화
`정의`
  - 시스템 오류로 인한 데이터베이스 서비스 중단이나 물리적 손상 발생 시 이를 복구하기 위해 **동일한 데이터베이스를 복제하여**

    **관리하는 것**이다.
  - 여러 개의 db를 동시에 관리하므로 사용자가 수행하는 작업은 데이터베이스 이중화 시스템에 연결된 다른 db에도 동일하게 작용한다.

`장점`
  - 하나 이상의 데이터베이스가 항상 같은 상태를 유지하므로 db에 문제가 발생하면 복제된 db를 이용해 즉시 문제를 해결할 수 있다.
  - 손쉽게 백업 서버를 운영할 수 있다.
  - 어플리케이션을 여러 개의 데이터베이스에서 분산 처리하므로 데이터베이스의 부하를 줄일 수 있다.

`분류`

1. `Eager 기법`
   - 트랜잭션 수행 중 데이터 변경이 발생하면 이중화된 모든 데이터베이스에 즉시 전달하여 변경 내용이 즉시 적용되도록 하는 기법
2. `Lazy 기법`
   - 트랜잭션의 수행이 종료되면 변경 사실을 새로운 트랜잭션에 작성하여 각 데이터베이스에 전달하는 기법
   - 데이터베이스마다 새로운 트랜잭션이 수행되는 것으로 간주됨
  
`구성 방법`

1. `활동-대기(Active-Standby) 방법`
   - 한 DB가 활성 상태로 서비스하고 있으면 다른 DB는 대기하고 있다가 활성 DB에 장애가 발생하면 대기 상테에 있던 DB가 자동으로
  
     모든 서비스를 대신 수행함
   - 구성 방법과 관리가 쉬워 많은 기업에서 이용된다.

2. `활동-활동(Active-Active) 방법`
   - 두 개의 DB가 서로 다른 서비스를 제공하다가 둘 중 한쪽 DB에 문제가 발생하면 나머지 다른 DB가 서비스를 제공함
   - 두 DB가 모두 처리를 하기 때문에 처리율이 높지만 구성 방법 및 설정이 복잡함
  
#### 클러스터링
`정의`
  - **두 대 이상의 서버를 하나의 서버처럼 운영하는 기술**이다.
  - 서버 이중화 및 공유 스토리지를 사용하여 서버의 고가용성을 제공한다.

`종류`

1. `고가용성 클러스터링`
   - 하나의 서버에 장애가 발생하면 다른 노드(서버)가 받아 처리하여 서비스 중단을 방지하는 방식
2. `병렬 처리 클러스터링`
   - 전체 처리율을 높이기 위해 하나의 작업을 여러 개의 서버에서 분산하여 처리하는 방식

> 고가용성(HA High Availability)이란 시스템을 오랜 시간동안 계속해서 정상적으로 운영이 가능한 성질을 의미한다.

##### RTO/RPO
`RTO(Recovery Time Objective, 목표 복구 시간)`
  - 비상사태 또는 업무 중단 시점으로부터 복구되어 가동될 때까지의 소요 시간을 의미함
    - 장애 발생 후 6시간 내 복구 가능
   
`RPO(Recovery Point Objective, 목교 복구 시점)`
  - 비상사태 또는 업무 중단 시점으로부터 데이터를 복구할 수 있는 기준점을 의미함
    - 장애 발생 전인 지난 주 금요일에 백업시켜 둔 복원 시점으로 복원 가능
   
#### DB 백업
`정의`
  - 전산 작업의 장애에 대비해 데이터베이스에 저장된 데이터를 보호하고 복구하기 위한 작업이다.

`로그 파일`
  - **데이터베이스의** 처리 내용이나 이용 상황 등 **상태 변화를 시간의 흐름에 따라 모두 기록한 파일**이다.
  - db 복구를 위해 필요한 가장 기본적인 자료이며 이 파일을 기반으로 db를 과거상태로 복귀(UNDO)시키거나

    현재상태로 재생(REDO)시켜 데이터베이스 상태를 일관성 있게 유지할 수 있다.

  - 트랜잭션 시작 시점, Rollback 시점, 데이터 입력, 수정, 삭제 시점 등에서 기록된다.

`알고리즘`

1. `NO-UNDO/REDO`
   - 데이터베이스 버퍼의 내용을 비동기적으로 갱신한 경우의 복구 알고리즘
   - NO-UNDO : 트랜잭션 완료 전엔 변경 내용이 db에 기록되지 않으므로 취소할 필요가 없음
   - REDO: 트랜잭션 완료 후 데이터베이스 버퍼에는 기록되어 있고, 저장매체에는 기록되지 않았으므로 트랜잭션 내용을 다시 실행해야 함

2. `UNDO/NO-REDO`
   - 데이터베이스 버퍼의 내용을 동기적으로 갱신한 경우의 복구 알고리즘
   - UNDO: 트랜잭션 완료 전에 시스템이 파손되었다면 변경된 내용을 취소함
   - NO-REDO: 트랜잭션 완료 전에 데이터베이스 버퍼 내용을 이미 저장 매체에 기록했으므로 트랜잭션 내용을 다시 시작할 필요 없음
  
3. `UNDO/REDO`
   - 데이터베이스 버퍼의 내용을 동기/비동기적으로 갱신한 경우의 복구 알고리즘
   - 데이터베이스 기록 전 트랜잭션이 완료될 수 있어 완료된 트랜잭션이 데이터베이스에 기록되지 못했다면 다시 실행해야 함

4. `NO-UNDO/NO-REDO`
   - 데이터베이스 버퍼의 내용을 동기적으로 저장 매체에 기록하지만 데이터베이스와는 다른 영역에 기록한 경우의 복구 알고리즘
   - NO-UNDO: 변경 내용은 데이터베이스와 다른 영역에 기록되어 있으므로 취소할 필요가 없음
   - NO-REDO: 다른 영역에 이미 기록되어 있으므로 트랜잭션을 다시 실행할 필요가 없음
  
`종류`
  - 복구 수준에 따라 운영체제를 이용하는 물리 백업, DBMS 유틸리티를 이용하는 논리 백업으로 나뉜다.

1. `물리 백업`
   - 데이터베이스 파일을 백업하는 방법이다.
   - 백업 속도가 빠르고 작업이 단순하지만 문제 발생 시 원인 파악 및 문제 해결이 어렵다.
  
2. `논리 백업`
   - DB내의 논리적 객체들을 백업하는 방법이다.
   - 복원 시 데이터 손상을 막고 문제 발생 시 원인 파악 및 해결이 수월하지만 백업/복원 시 시간이 많이 소요된다.
  
#### Storage
`정의`
  - 단일 디스크로 처리할 수 없는 **대용량의 데이터를 저장하기 위해 서버와 저장장치를 연결하는 기술**이다.
  - 종류엔 `DAS`, `NAS`, `SAN`이 있다.

`종류`

1. `DAS(Direct Attached Storage)`
   - **서버와 저장장치를 전용 케이블로 직접 연결하는 방식**이다.
     - 컴퓨터에 외장하드를 연결하는 방식이 이에 해당 
   - 저장장치를 직접 연결하여 속도가 빠르고 설치 및 운영이 쉽다.
   - 초기 구축 비용 및 유지보수 비용이 저렴하다.
   - 직접 연결 방식이라 타 서버에서 접근이 불가하며 파일을 공유할 수 없다.
     - 확장성 및 유연성이 떨어진다.
    
2. `NAS(Network Attached Storage)`
   - **서버와 저장장치를 네트워크를 통해 연결하는 방식**이다.
   - 별도의 파일 관리 기능이 있는 NAS Storage가 내장된 저장장치를 직접 관리한다.
   - Ethernet 스위치를 통해 다른 서버에서도 스토리지에 접근할 수 있어 파일 공유가 가능하다.
     - 장소에 구애받지 않고 저장장치에 쉽게 접근이 가능하다. 
   - DAS에 비해 확장성 및 유연성이 뛰어나다.
  
3. `SAN(Storage Area Network)
   - DAS의 빠른 처리와 NAS의 파일 공유 장점을 혼합한 방식으로 **서버와 저장장치를 연결하는 전용 네트워크를 별도로 구성하는 방식**이다.
   - 광 채널(FC) 스위치를 이용해 네트워크를 구성한다.
     - 서버와 저장장치를 광케이블로 연결하여 처리속도가 빠르다.
   - 저장장치를 공유하여 여러 개의 저장장치나 백업 장비를 단일화시킬 수 있다.
   - 확장성 , 유연성 , 가용성이 뛰어나다.

#### 트리거(Trigger)
`정의`
- dbms에서 데이터의 삽입(Insert), 갱신(Update), 삭제(Delete) 등의 **이벤트가 발생할 때 관련 작업이 자동으로 수행되게 하는 절차형 SQL**이다.
- 트리거는 db에 저장되며 데이터 변경 및 무경성 유지, 로그 메시지 출력 등의 목적으로 사용된다.
- 트리거의 구문엔 DCL(데이터 제어어)을 사용할 수 없으며, DCL이 포함된 프로시저나 함수를 호출하는 경우에 오류가 발생한다.

<details>
<summary><strong> 트리거 구성도 </strong></summary>
<div>

- `DECLARE(필수)`
  - 트리거의 명칭, 변수 및 상수, 데이터 타입을 정의하는 선언부이다.
- `EVENT(필수)`
  - 트리거가 실행되는 조건을 명시한다.
- `BEGIN/END(필수)`
  - 트리거의 시작과 종료를 의미한다.
  - `CONTROL`
    - 조건문 또는 반복문이 삽입되어 순차적으로 처리된다.
  - `SQL`
    - DML문이 삽입돼 데이터 관리를 위한 조회, 추가, 수정, 삭제 작업을 수행한다.
  - `EXCEPTION`
    - BEGIN ~ END 안의 구문 실행 시 예외가 발생하면 이를 처리하는 방법을 정의한다.

</div>
</details>

`트리거 생성`
-  트리거를 생성하기 위해서는 CREATE TRIGGER 명령어를 사용한다.

<details>
<summary><strong> 트리거 생성 시 표기 옵션 </strong></summary>
<div>

``` sql
CREATE [OR REPLACE] TRIGGER 트리거명 [동작시기 옵션][동작 옵션] ON 테이블명
REFERENCING [NEW | OLD] AS 테이블명
FOR EACH ROW
[WHEN 조건식]
BEGIN
    트리거 BODY;
END;
```

- `OR REPLACE`
  - 선택적 예약어이다. 이 예약어 사용시 동일한 트리거 이름이 이미 존재하는 경우 대체할 수 있다.
- `동작시기 옵션`
  - 트리거가 실행될 때를 지정한다.
  - AFTER
    - 테이블이 변경된 후에 트리거가 실행된다.
  - BEFORE
    - 테이블이 변경되기 전에 트리거가 실행된다.
- `동작 옵션`
  - 트리거가 실행되게 할 작업의 종류를 지정한다.
  - INSERT
    - 테이블에 새로운 튜플을 삽입할 때 트리거가 실행된다.
  - DELETE
    - 테이블에 새로운 튜플을 삭제할 때 트리거가 실행된다.
  - UPDATE
    - 테이블에 새로운 튜플을 수정할 때 트리거가 실행된다.
- `NEW | OLD`
  - 트리거가 적용될 테이블의 별칭을 지정한다.
  - NEW
    - 추가되거나 수정에 참여할 튜플들의 집합(테이블)을 의미한다.
  - OLD
    - 수정되거나 삭제 전 대상이 되는 튜플들의 집합(테이블)을 의미한다.
- `FOR EACH ROW`
  - 각 튜플마다 트리거를 적용한다는 의미이다.
- `WHERE 조건식`
  - 선택적인 예약어이다. 트리거를 적용할 튜플의 조건을 지정한다.
- `트리거 BODY`
  - 트리거의 본문 코드를 입력하는 부분이다.
  - BEGIN 으로 시작해서 END로 끝나는데 적어도 하나 이상의 SQL문이 있어야 한다. 그러지 않으면 오류 발생

</div>
</details>

`트리거 제거`
- 트리거 제거를 위해선 DROP TRIGGER 명령어를 사용한다.



### 정규화
`정의`
  - **정규화는 데이터의 일관성, 최소한의 데이터 중복, 최대한의 데이터 유연성을 위한 방법이며 데이터를 분해하는 과정**이다.
  - **정규화는 데이터 중복을 제거하고 데이터 모델의 독립성을 확보하기 위한 방법**이다.
  - 정규화를 수행할 시 비지니스의 변화가 생겨도 데이터 모델의 변경을 최소화 할 수 있다.
  - 정규화는 제1정규화부터 제5정규화까지 있지만 **실질적으로는 제3 정규화까지 진행**한다.

> 정규화를 진행하지 않은 테이블에서 컬럼의 원자성이 보장되어 있지 않을 때 CRUD를 진행하며 불필요한 값이 들어가는 현상을<br>
> `이상현상(Anomaly)`이라고 한다.
>> 이러한 이상현상을 막기 위해선 테이블을 분해 즉 정규화를 진행해야 한다.

- 정규화된 모델은 테이블이 분해되며 테이블이 분해되면 조인(Join)을 진행하여 합집합을 만들 수도 있다.
- 정규화를 수행하면 불필요한 데이터를 입력하지 않아도 되기 때문에 중복된 데이터가 제거된다.

`정규화 절차`
|정규화 절차 | 설명 |
| :--: | :--:|
| 제1정규화 | - 속성(Attribute)의 원자성을 확보한다. <br> - 기본키(Primary)를 설정한다.|
| 제2정규화 | - 기본키가 2개 이상의 속성으로 이루어진 경우 **부분 함수 종속성**을 제거(분해)한다.|
| 제3정규화 | - 기본키를 제외한 칼럼 간에 종속성을 제거한다. <br> - 즉 **이행 함수 종속성**을 제거한다.|
| BCNF | - 기본키를 제외하고 후보키가 있는 경우 후보키가 기본키를 종속시키면 제거한다.|
| 제4정규화 | - 여러 칼럼들이 하나의 칼럼을 종속시키는 경우 분해하여 다중값 종속성을 제거한다.|
| 제5정규화 | - 조인에 의해서 종속성이 발생하는 경우 분해한다. |

#### 제1정규화
  - 정규화는 **함수적 종속성을 근거**로 한다.
    - **함수적 종속성이란 X->Y이면 Y는 X에 함수적으로 종속**된다고 한다.
    - 함수적 종속성에선 X가 변하면 Y도 변하는지 확인하며 회원ID가 변할때 이름도 변경되는 경우 회원ID가 기본키가 되고 

      **회원 ID가 이름을 함수적으로 종속**한다고 한다.
  - **기본키를 잡고, 원자성을 확보하는 것이** 제1정규화라고 할 수 있다.

#### 제2정규화
  - **부분함수 종속성이란 기본키가 2개 이상의 칼럼으로 이루어진 경우에만 발생**한다.
  - **기본키가 하나의 칼럼으로 이루어지면 제2정규화는 생략**한다.
  - 기본키가 2개 이상 존재하고 각각의 기본키가 칼럼을 함수적으로 종속시키는 상황을 부분함수 종속성이라 하고 이때 제2정규화를 진행한다.

#### 제3정규화
  - 제3정규화는 이행 함수 종속성을 제거한다.
    - **이행 함수 종속성이란 기본키를 제외하고 칼럼간에 종속성이 발생**하는 것을 말한다.
  - 제3정규화는 제1정규화, 제2정규화 후에 진행해야 한다.

#### BCNF(Boyce-Codd Normal Form)
  - **BCNF는 복수의 후보키가 있고 후보키들이 복합 속성이어야 하며 서로 중첩되어야 한다.**
  - EX: 학생ID와 과목 번호가 복수의 기본키로 존재하고 교수가 칼럼으로 존재하면서 교수가 과목 번호를 함수적으로 종속시키는 상황
     - 이때 교수에 따른 과목은 종속되어 생기지만 과목이 개설되지 않은경우 학생이란 PK는 이상이 생김 ->삽입,갱신,삭제 이상 등
     - 이때 교수와 과목 번호를 분리하는 것을 BCNF라고 함

#### 정규화의 문제점
1. 정규화는 테이블을 분해해서 데이터의 중복을 제거하기 때문에 테이블의 수가 늘어날 수 밖에 없고 이로 인한

   **데이터 조회(SELECT)시에 조인(JOIN)을 유발하기 때문에 CPU와 메모리를 많이 사용**한다.
 
2. 테이블의 데이터의 건수가 많을때 비교해야 하는 건수가 늘어나는 비효율성이 증가한다.(CPU 부하, 메모리 점유율 증가)
  -  **인덱스, 옵티마이저**를 통해서 이러한 비효율성을 해결한다.
     - 옵티마이저란 가장 효율적인 방법으로 SQL을 수행할 최적의 처리 경로를 생성해주는 DBMS의 핵심 엔진이다.
     - 컴퓨터의 두뇌가 CPU라면 DBMS의 두뇌는 옵티마이저라고 할 수 있다.
     - 인덱스란 RDBMS에서 검색 속도를 높이기 위한 기술이다.
     - TABLE의 컬럼을 색인화(따로 파일로 저장)하여 검색시 해당 테이블의 레코드를 FULL SCAN 하는게 아니라 따로

       색인화 되어있는 INDEX 파일을 검색하여 검색속도를 빠르게 한다.
       
> 결론적으로 조인이 부하를 유발하는 것은 분명하므로 이런 성능 저하를 해결하기 위해 반정규화라는 방법이 존재하는 것이다.
> 반정규화를 통해 하나의 테이블에 데이터를 저장한다면 조인을 통한 성능 저하를 해결할 수 있기 때문

##### 정규화를 통한 성능 튜닝
- **조인으로 인한 성능이 저하되는 문제를 반정규화로 해결**할 수 있다.
- **반정규화는 데이터를 중복**시키기 때문에 또 다른 문제를 야기시킨다.

`정규화와 반정규화의 장단점 및 비교`

```
반정규화를 통해 조인을 통한 성능 저하를 해결하게 됐을 때에도 너무 많은 칼럼이 존재하게 된다면 한 개 한 행의 크기가
DBMS의 입출력 단위은 블록의 크기(Block Size)를 넘어서게 되고 이때 한 개의 행을 읽기 위해 여러 개의 블록을 읽어야 한다.
위와 같은 상황에선 디스크 입,출력이 증가하기 때문에 성능이 저하되고 반정규화는 이러한 문제점을 갖고있다고 할 수 있다.
이 상황에선 테이블을 분해하는 방법밖에는 없으며 정규화는 입출력 데이터의 양을 줄여 성능을 향상시킬 수 있다.
```

### 반정규화(De-Normalization)
`정의`
  - **데이터베이스의 성능 향상을 위해서 데이터 중복을 허용하고 조인을 줄이는 데이터베이스 성능 향상 방법**이다.
  - **반정규화는 조회(SELECT)속도를 향상시키지만, 데이터 모델의 유연성은 낮아진다.**

`반정규화를 수행하는 경우`
   1. 정규화에 충실하면 종속성, 활용성은 향상되지만 수행 속도가 느려지는 경우
   2. 다량의 범위를 자주 처리해야 하는 경우
   3. 특정 범위의 데이터만 자주 처리하는 경우
   4. 요약/집계 정보가 자주 요구되는 경우

`반정규화 절차`

|반정규화 절차| 설명|
|:--:|:--:|
|대상 조사 및 검토| - 데이터 처리 범위, 통계성 등을 확인해서 반정규화 대상을 조사한다.|
|다른 방법 및 검토| - 반정규화를 수행하기 전에 다른 방법이 있는지 검토한다. <br> - 예로 클러스터링 , 뷰, 인덱스 튜닝, 응용 프로그램, 파티션 등을 검토한다.|
|반정규화 수행 | - 테이블 속성, 관계 등을 반정규화 한다.|

```
클러스터링(Clustering)
클러스터링 인덱스라는 것은 인덱스 정보를 저장할때 물리적으로 정렬해서 저장하는 방법이다.
조회시에 여러 블록을 연속적으로 읽기 때문에 성능이 향상된다.
```

#### 반정규화 기법
1. 계산된 칼럼 추가
   - 배치 프로그램으로 총 판매액, 평균잔고, 계좌평가 등을 미리 계산하고, 그 결과를 특정 칼럼에 추가한다.
2. 테이블 수직분할
   - 하나의 테이블을 두 개 이상의 테이블로 분할한다. 즉 칼럼을 분해하여 새로운 테이블을 만드는 것이다.
3. 테이블 수평분할
   - 하나의 테이블에 있는 값을 기준으로 테이블을 분할하는 방법이다.

`파티션(Partition) 기법`
  - 데이터베이스에서 파티션을 사용해서 테이블을 분할할 수 있다.
  - 파티션을 사용하게되면 논리적으로는 하나의 테이블이지만 여러 개의 테이블 파일에 분산되어 저장된다.
1. Range Partition 
  - 데이터 범위를 기준으로  파티션을 수행한다
2. List Partition 
  - 특정한 값을 지정하여 파티션을 수행한다.
3. Hash Partition 
  - 해시함수를 적용하여 파티션을 수행한다.
4. Composite Partition
  - 범위와 해시를 복합적으로 사용하여 파티션을 수행한다.

```
해시 함수는 임의의 길이를 갖는 메세지를 입력 받아 고정된 길이의 해시 값을 출력하는 함수이다.
암호 알고리즘에는 키가 사용되지만 해시 함수는 키를 사용하지 않으므로 같은 입력에는 항상 같은 출력이 나오게 된다.
해시 함수의 목적은 메세지의 오류나 변조를 탐지할 수 있는 무결성을 제공하기 위해 사용된다.
```
`파티션 테이블의 장점`
  - 데이터 조회시에 엑세스(Access)범위가 줄어들기 때문에 성능이 향상된다.
  - 데이터가 분할 되어 있기 때문에 I/O(Input/Output)의 성능이 향상된다.
  - 각 파티션을 독립적으로 백업 및 복구가 가능하다.

4. 테이블 병합
  - 1:1 관계의 테이블을 하나의 테이블로 병합시켜 성능을 향상시킨다.
  - 1:N 관계의 테이블을 병합시켜 성능을 향상시킨다. 하지만 많은 양의 데이터 중복이 발생한다.
  - 슈퍼타입과 서브타입의 관계가 발생하면 테이블을 통합하여 성능을 향상시킨다.
    - 고객 엔터티는 개인, 법인 고객으로 나뉠 수 있는데 이때 고객 엔터티는 Super Type 개인, 법인 고객은 Sub Type으로 나뉜다.
    - 슈퍼 타입과 서브 타입은 배타적 관계와 포괄적 관계가 있다.
      - 배타적 관계는 고객이 개인고객이거나 법인 고객인 경우를 의미한다.
      - 포괄적 관계는 고객이 개인고객일 수도 있고 법인 고객일 수도 있는 경우를 의미한다.
 
|변환 방법|설명|
|:--:|:--:|
|OneToOne Type(1:1)| - 슈퍼타입과 서브타입을 개별 테이블로 도출한다. <br> - 테이블의 수가 많아서 조인이 많이 발생하고 관리가 어렵다.|
|Plus Type(Super + Sub) | - 슈퍼 타입과 서브 타입 테이블로 도출한다. <br> - 조인이 발생하고 관리가 어렵다.|
|Single Type(All in One) | - 슈퍼 타입과 서브 타입을 하나의 테이블로 도출한다. <br> - 조인 성능이 좋고 관리가 편하지만 , 입출력 성능이 나쁘다.|










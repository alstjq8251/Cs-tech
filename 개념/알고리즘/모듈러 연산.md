## 모듈러 연산이란?
`정의`
- 모듈러 연산이란 어떤 한 숫자를 다른 숫자로 나눈 나머지를 구하는 연산이다.

a mod m = r (단, 0≤r<m)

**예시:**
- \( 15 \mod 5 = 0 \)
- \( 10 \mod 5 = 0 \)
- \( 7 \mod 3 = 1 \)

### 모듈러 연산의 특징
1. **동일 모듈러의 합/차/곱:**<br>
   \[
   (a + b) \mod m = [(a \mod m) + (b \mod m)] \mod m
   \]<br>
   \[
   (a - b) \mod m = [(a \mod m) - (b \mod m) + m] \mod m
   \]<br>
   \[
   (a \times b) \mod m = [(a \mod m) \times (b \mod m)] \mod m
   \]

2. **동일한 모듈러의 동치성:**<br>
   \[
   a≡b(modm)이면,a+c≡b+c(modm)이고,a×c≡b×c(modm)이다..
   \]

3. **거듭제곱의 모듈러:**<br>
   \[
   (a^k) \mod m = [(a \mod m)^k] \mod m
   \]<br>
   이는 큰 수의 거듭제곱을 효율적으로 계산할 때 유용하다.

### 모듈러 연산 시 음수 처리
- 언어에 따라 음수에 대한 모듈러 연산의 결과가 다를 수 있고 수학적으로는 항상 \( 0 \) 이상 \( m-1 \) 이하의 나머지를 사용해야 한.
  
- \[
   remainNo = (a \mod m + m) \mod m
  \]

### 모듈러 연산이 활용될때 아이디어

- 구간 합이 \( M \)으로 나누어 떨어진다는 것은, 두 누적 합의 차이가 \( M \)의 배수임을 의미한다. 즉,

[
prefixSum[j] - prefixSum[i] = 0 \pmod{M}
]

이는 다시,

[
prefixSum[j] = prefixSum[i] \pmod{M}
]

**동일한 모듈러 값을 가지는 누적 합의 쌍**이 존재할 때마다 해당 조건을 만족하는 구간이 하나씩 증가한다.

**결론**

[
prefixSum[j] = prefixSum[i] \pmod{M}
]

이는 \( prefixSum[j] \)와 \( prefixSum[i] \)가 같은 나머지를 가짐을 의미한다.

**예시:**
- \( -1 \mod 9 = 8 \)
- \( -4 \mod 5 = 1 \)

### 모듈러 연산의 활용 예

- 모듈러 연산은 수열의 합을 특정 값으로 나누었을 때의 나머지를 활용하는 중요한 수학적 연산
- 이 개념들은 특히 수열에서 특정 조건을 만족하는 구간을 효율적으로 찾는 데 유용하다.
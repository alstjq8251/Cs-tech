### 도커란?
```
- 도커는 개발환경이 달라 생기는 문제를 해결하기 위해 나온 컨테이너 기반 가상화 도구이다.
- 격리된 가상 배포 환경도구인 도커는 vm과 비교되는데 OS를 부팅시키지 않고 격리된 컨테이너에서 어플리케이션을 실행할 수 있어 시간이 빠르게 단축된다.
- 애플리케이션 격리 Api와 서버를 격리해야 하는 경우 도커는 컨테이너를 각각 독립된 공간에서 실행시키기 때문에 해결이 가능하다.
- 모든 환경에서 실행이 가능한 구성 단순화 , 환경 자체를 읽어 컨테이너로 실행시키기 때문에 코드 관리 ,개발 생산성 향상의 특징이 있다.
```

#### 도커같은 컨테이너 기술이 나오게 된 배경
<img width="1132" alt="image" src="https://user-images.githubusercontent.com/98382954/212711662-e3397dc6-b91d-4acc-b4b0-b46f965e8d8a.png">

1.`VM(가상 머신)`의 탄생 배경
```
서비스를 운영하는 사용자 및 기업들의 경우엔 Host의 자원을 효율적으로 사용해야 한다.(자원의 효율성)
  어플리케이션을 다중으로 실행하는 경우 앱간 바이너리(종속성)의 충돌로 예기치않은 오류가 발생시킬 수 있으며 
  이는 자원이 허락하는 한도내 앱을 다중으로 띄우기 어렵다는것을 의미한다.(격리 필요)
Host Os가 window인 경우 Linux등 다른 os를 기반으로 동작하는 앱들을 사용할 수 없다(OS상이)
```
  - 이러한 필요성들로 VM이 탄생했으며 VM들을 동작시키는 Hipervisor및 다양한 가상화 기술들이 등장하게 되었다.
    - 해당 배경들은 추후 가상화 기술편에서 기술하여 연동시킬예정

2.컨테이너 기술의 등장 배경
```
VM(가상 머신)은 Hipervisor(가상화 소프트 웨어 도구)를 기반으로 각각의 Guest Os를 구동시켜 앱을 동작해야만 했다.(자원의 오버헤드↑)
VM(가상 머신)은 Infra(하드웨어)-Host os - Hipervisor - Guest os - Application 앱을 구동시키기까지 많은 레이어계층을 거쳐야 한다.(성능 저하)
VM(가상 머신)을 사용하여 앱을 실행시키기 위해선 필연적으로 Hipervisor로 Guest Os를 구동시키며 Host의 자원을 할당받아 앱에 필요한 라이브러리등을 
설치하기까지 앱 하나를 실행시키거나 VM간 앱을 이전하는 경우 앱 이전이 쉽지 않다.(경량화의 필요)
 ```
- 이러한 점들로 자원은 효율적으로 사용하며 각각의 앱들을 서로를 방해하지않는 격리된 환경에서 성능 향상 및 VM을 띄우기 위해 발생하는 오버헤드를 줄이기 위해 
    컨테이너 기술이 나왔다고 할 수 있다.
    
> 도커는 Linux를 기반으로 한 애플리케이션 격리&관리 기술이며 각기 다른 OS를 구동시킬 순 없고 Host Os의 커널을 공유해서 사용하기 때문에 Linux가 
> 아닌 환경에서 도커를 사용하긴 어려우며(예기치 않은 오류↑) 앱을 다중으로 실행시킬 경우에도 VM이 나을 수 있으니 서로의 장단점을 명확히 이해하며 
> 기술을 공부하고 사용해야 하며 모든 상황에서 컨테이너 격리 기술이 낫다는 것이 아니라는 것을 명심해야 한다.
    
### 도커의 장점
- `VM과 비견되는 성능 향상`
- `자원의 오버헤드 최소화`
- `애플리케이션들의 격리`
- `앱을 실행시키는 구조의 경량화`

##### 오버헤드란?
- `오버헤드`는 특정한 기능을 수행하기 위해 추가로 사용되는 컴퓨터 자원을 명하는 것이다.
  - 앱을 실행시키기 위해서 VM을 구동해야하는 경우 추가로 사용되는 자원들이 생길 때 오버헤드가 생기며 그 양에 따라 많고 적음을 분류한다.

### 도커의 구성 요소?
<img width="920" alt="image" src="https://user-images.githubusercontent.com/98382954/212716913-226b7a24-1fd4-4101-a0cf-bda4f98d9e04.png">

1. Client
  - 도커는 모든 명령어의 앞에 Docker를 붙여 통신하게 되는데 이 명령어들을 입력받아 동작하는 cli를 Client라 한다.
  - docker_host에 위치한 Docker daemon에게 통신&명령을 내리며 사용자가 입력하는 명령어들을 Docker daemon에게 전달하며 입력을 기다린다.

2.Docker_Host
  - docker run,stop등 컨테이너들의 생명주기를 관장하는 명령어들을 실행하는 docker daemon이 위치해있다.
  - 컨테이너를 동작시키기 위한 registry에서 이미지를 pull받아 이미지 및 컨테이너를 관리한다(docker daemon)
  - volume,network등 docker process와 그에 필요한 모든것들을 관리한다.

3.Docker-Registry
  - 컨테이너를 실행시키기 위한 image를 저장하고 있는 저장소다.
  - public한 docker hub부터 private한 nexus등의 registry가 존재한다.

### 도커의 이미지와 컨테이너
<img width="991" alt="image" src="https://user-images.githubusercontent.com/98382954/212721369-c048f891-fb35-4089-a64e-8f13a7e4bb9f.png">

- 위 사진과 같이 도커는 도커 파일(이미지를 만들기 위한 명세서)를 기반으로 이미지를 빌드하여 그 이미지를 토대로 컨테이너를 실행시키는 구조로 되어있다.
  - 도커파일 없이 명령어들로 이미지를 만들거나 Jip의 형태로 이미지를 빌드할 수도 있다.
  - 이미지들은 registry에 저장되어 사내 및 다른 서버에서 실행시킬때 pull받아 사용된다. 

#### 도커의 이미지란?
- `컨테이너`즉 어플리케이션을 실행시키기 위해 필요한 모든 바이너리(종속성), 라이브러리 , 프레임워크등의 요소가 들어있다.
- 도커의 이미지는 `레이어 계층`으로 구성되어 있다.

![image](https://user-images.githubusercontent.com/98382954/212722335-9f18856b-fdb3-4aff-970f-e7dbcc7dcf80.png)

- 도커의 이미지는 사진과 같이 앱을 실행시키기 위해 필요한 파일들이 순서에 따라 레이어 계층 구조로 쌓아져 있는 구조로 만들어져 있다.
  - 변경 사항들은 순차적으로 위에서 하나씩 더해져가기 때문에 앱을 구동시키기 위한 파일들의 순서를 추적하기 용이하다.
  - 변경된 파일들은 위로 하나씩 쌓아져 이미지로 빌드되기 때문에 파일들을 관리하기가 쉽다.
  - 사진과 같이 재사용되는 앱을 실행시킬때 재사용되는 이미지들은 기반이미지로 자리잡아 새로 사용될 레이어만 위로 쌓아 새로 이미지를 만든다(성능 향상)

![image](https://user-images.githubusercontent.com/98382954/212723093-3a518828-e116-4619-8dd5-c71d5cd5453e.png)

  - 레이어 계층구조로 빌드하게 되면 이미 사용된 레이어 계층은 재사용하여 빠르게 이미지를 빌드하는것이 가능하다(성능 향상)

- 이미지의 설정파일등은 컨테이너를 동작시키기 위해 필요하며 컨테이너 동작 여부와 상관없이 바뀌지 않는다.(ReadOnly)
- 컨테이너의 레이어 계층들은 이미지로 다시 빌드시키지 않는한 변경사항들이 반영되진 않는다.(Read-Write 레이어 계층)

#### 도커의 컨테이너란?
- 앱을 실행시키기 위한 파일들이 모여있는 이미지를 기반으로 격리된 환경에서 구동된 프로세스이며 앱이다.

#### Reference
<https://aidanbae.github.io/code/docker/docker-overview/><br>
<Kubernetes와 Docker로 한 번에 끝내는 컨테이너 기반 MSA-fastcampus>  

## 소프트웨어 아키텍처
`정의`
 - **소프트웨어를 구성하는 요소들 간의 관계를 표현하는 시스템의 구조 또는 구조체**이다.
 - 기본 원리에는 `모듈화`, `추상화`, `단계적 분해`, `정보은닉`이 있다.

`모듈화`
- 소프트웨어의 성능 향상 , 시스템의 수정 및 재사용, 유지 관리 등이 용이하도록 **시스템의 기능들을 모듈 단위로 나누는 것**을 의미
- 모듈의 단위를 너무 작게하면 개수가 많아 통합 비용이 많이 든다.
- 단위를 너무 크게 나우면 개수가 적어 통합 비용은 적지만 모듈 하나의 개발 비용이 많이 든다.

> 모듈은 전체 프로그램의 기능 중에서 특정 기능을 처리할 수 있는 소스 코드를 의미한다.

`추상화`
- 문제의 **전체적이고 포괄적인 개념을 설계한 후** 차례로 세분화하여 **구체화시켜 나가는 것**이다.
- 유형
  - `과정 추상화`
    - 자세한 수행 과정을 정의하지 않고, 전반적인 흐름만 파악할 수 있게 설계하는 방법
  - `데이터 추상화`
    - 데이터의 세부적인 속성이나 용도를 정의하지 않고, 데이터 구조를 대표할 수 있는 표현으로 대체하는 방법
  - `제어 추상화`
    - 이벤트 발생의 정확한 절차나 방법을 정의하지 않고, 대표할 수 있는 표현으로 대체하는 방법

`단계적 분해`
- 문제를 **상위의 중요 개념으로부터 하위의 개념으로 구체화시키는 분할 기법**이다.
- Niklaus Wirth에 의해 제안된 하향식 설계 전략이다.
- 소프트웨어의 포괄적 기능에서 시작해 구체화하고, 알고리즘, 자료구조등 상세한 내역은 가능한 뒤로 미뤄 진행한다.

`정보 은닉(Information Hiding)`
- **모듈 내부에 포함된 절차와 자료들의 정보가 감춰져 다른 모듈이 접근하거나 변경하지 못하도록 하는 기법**이다.
- 모듈을 독립적으로 수행 가능하도 하나의 모듈이 변경되도 다른 모듈에 영향을 주지 않아 수정, 시험, 유지보수가 용이하다.

`상위 설계와 하위 설계`

| | 상위 설계 | 하위 설계 |
|:--: | :--: | :--: |
| 별칭 | 아키텍처 설계 , 예비 설계 | 모듈 설계, 상세 설계 |
| 설계 대상 | 시스템의 전체적인 구조 | 시스템의 내부 구조 및 행위 | 
| 세부 목록 | 구조, DB, 인터페이스 | 컴포넌트, 자료 구조, 알고리즘 |

`품질 속성`
- 소프트웨어 아키텍처가 이해관계자들이 요구하는 수준의 품질을 유지 및 보장할 수 있게 설계됐는지 확인하기 위해 품질 평가 요소를 구체화 시켜 놓은 것
- `종류`
    - 시스템 측면
      - 성능, 보안, 가용성, 기능성, 사용성, 변경 용이성, 확장성 등
    - 비지니스 측면
      - 시장 적시성, 비용과 혜택, 예상 시스템 수명, 목표 시장, 공개 일정 등
    - 아키텍처 측면
      - 개념적 무결성, 정확성, 완결성, 구축 가능성, 변경성, 시험성 등

`소프트웨어 아키텍처 4+1뷰`

| 뷰 | 설명 |
| :--: | :--: |
| 유스케이스 뷰 <br>(Usecase View) | 유스케이스 또는 아키텍처를 도출하고 설계하며 다른 뷰를 검증하는 데 사용되는 뷰 <br> 사용자, 설게자, 개발자, 테스트 관점 |
| 논리 뷰 <br> (Logical View) | 시스템의 기능적인 요구사항이 어떻게 제공되는지 설명해주는 뷰 <br> 설계자, 개발자 관점 |
| 프로세스 뷰 <br> (Process View) | 시스템의 비기능적인 속성으로서 자원의 효율적인 사용, 병행 실행, 비동기, 이벤트 처리 등을 표현한 뷰 <br> 개발자, 시스템 통합자 관점 |
| 구현 뷰 <br> (Implementation View) | 개발 환경 안에서 정적인 소프트웨어 모듈의 구성을 보여주는 뷰 <br> 컴포넌트 구조와 의존성을 보여주고 컴포넌트에 관한 부가적인 정보 정의 |
| 배포 뷰 <br> (Deployment View) | 컴포넌트가 물리적인 아키텍처에 어떻게 배치되는가를 매핑해서 보여주는 뷰 |

`설계 과정`
1. 설계 목표 설정
2. 시스템 타입 결정
3. 아키텍처 패턴 적용
4. 서브시스템 구체화
5. 검토

`협약에 의한 설계`
- **컴포넌트를 설계할 때 클래스에 대한 여러 가정을 공유할 수 있도록 명세한 것**이다.

<details>
<summary><strong>명세에 포함될 조건</strong></summary>
<pre>

| 조건 | 내용 |
| :--: | :--: |
| 선행 조건<br>(Precondition) | 오퍼레이션이 호출되기 전에 참이 되어야 할 조건 |
| 결과 조건<br>(Postcondition) | 오퍼레이션이 수행된 후 만족되어야 할 조건 |
| 불변 조건<br>(Invariant) | 오퍼레이션이 실행되는 동안 항상 만족되어야 할 조건 |

</pre>
</details>

### 아키텍처 패턴
`정의`
- **아키텍처를 설계할 때 참조할 수 있는 전형적인 해결 방식 또는 예제를** 의미한다.
- 소프트웨어 시스템의 구조를 구성하기 위한 기본적인 윤곽을 제시한다.
- 서브시스템들과 그 역할이 정의되어 있으며 서브시스템 사이 관계와 여러 규칙, 지침 등이 포함되어 있다.

`주요 아키텍처 패턴의 종류`

1. `레이어 패턴(Layers Pattern)`
    - **시스템을 계층으로 구분하여 구성하는** 고전적인 방법의 패턴이다.
    - 하위 계층은 상위 계층에 대한 서비스 제공자가 되고, 상위 계층은 하위 계층의 클라이언트가 된다.
    - 마주보는 두 계층 사이에서만 상호작용이 이뤄지며 대표적으로 OSI 참조 모델이 있다.
    - n티어 아키텍처라고도 불리며 하위 모듈들의 구조화된 프로그램에서 사용할 수 있다.
    - 일반적으로 볼 수 있는 계층은 하위 4계층과 같다.
      1. 프레젠테이션 계층 (Presentation layer) - UI 계층 (UI layer) 이라고도 함
      2. 애플리케이션 계층 (Application layer) - 서비스 계층 (Service layer) 이라고도 함
      3. 비즈니스 논리 계층 (Business logic layer) - 도메인 계층 (Domain layer) 이라고도 함
      4. 데이터 접근 계층 (Data access layer) - 영속 계층 (Persistence layer) 이라고도 함

![image](https://github.com/alstjq8251/Cs-tech/assets/98382954/d734f4e5-25c4-4117-a982-9db089b1f6cc)

2. `클라이언트-서버 패턴(Client-Server Pattern)`
   - **하나의 서버 컴포넌트와 다수의 클라이언트 컴포넌트로 구성되는 패턴**이다.
   - 사용자가 클라이언트를 통해 서버에 요청하면 클라이언트가 응답 받아 사용자에게 제공하는 방식이다.

![image](https://github.com/alstjq8251/Cs-tech/assets/98382954/e7180e10-a26b-4c86-87c0-2e85d30b4270)

3. `파이프-필터 패턴(Pipe-Filter Pattern)`
    - **데이터 스트림의 절차**의 각 단계를 **필터로 캡슐화하여 파이프를 통해 전송하는 패턴**이다.
    - 앞 시스템의 처리 결과물을 파이프를 통해 전달받아 처리한 후 그 결과물을 다시 파이프를 통해 다음 시스템으로 넘겨주는 패턴을 반복한다.
    - 데이터 변환, 버퍼링, 동기화 등에 자주 사용된다.

![image](https://github.com/alstjq8251/Cs-tech/assets/98382954/3eeec885-7728-4ad3-8887-377b754947fd)

4. `모델-뷰-컨트롤러 패턴(Model-View-Controller Pattern)`
    - **서브 시스템을 모델, 뷰, 컨트롤러로 구조화하는 패턴**이다.
    - 컨트롤러가 사용자의 요청을 받으면 핵심 기능과 데이터를 보관하는 모델을 이용해 뷰에 정보를 출력하는 구조이다
        - 모델 : 핵심 기능과 데이터 포함
        - 뷰 : UI를 의미하며 사용자에게 정보 표시(1orN)
        - 컨트롤러 : 사용자의 요청 처리

![image](https://github.com/alstjq8251/Cs-tech/assets/98382954/f8acae9e-b896-4ac9-88e9-39aafca87adc)

5. `마스터 슬레이브 패턴(Master-Slave Pattern)`
   - 슬레이브 컴포넌트에서 처리된 결과물을 다시 돌려받는 방식으로 작업을 수행하는 패턴
   - DB등 고가용성 관점에서 마스터와 동기화 되어있는 슬레이브가 마스터가 장애가 발생했을때 데이터 보존 , 기능 유지 등의 작업을 할 수 있게 하는 패턴이다.

![image](https://github.com/alstjq8251/Cs-tech/assets/98382954/52c8b0c0-fea8-4036-bf15-35d0326fd41e)

6. `브로커 패턴(Broker Pattern)`
   - 사용자가 원하는 서비스와 특성을 브로커 컴포넌트에 요청하면 브로커 컴포넌트가 요청에 맞는 컴포넌트와 사용자를 연결하는 패턴
   - 분산 환경 시스템에서 이용되며 브로커 컴포넌트는 컴포넌트간 통신 중개자 역할을 한다.
   - Apache Kafka, RabbitMq

![image](https://github.com/alstjq8251/Cs-tech/assets/98382954/bb1fb19e-68a5-4bca-9d1b-72ede2939f43)

7. `피어-투-피어 패턴(Peer-To-Peer Pattern)`
   - 피어(Peer)라 불리는 하나의 컴포넌트가 클라이언트가 될 수도 서버가 될 수도 있는 패턴
   - Gnutella나 G2와 같은 파일 공유 네트워크가 그러한 패턴을 사용하고 있다.

8. `이벤트-버스 패턴(Event-Bus Pattern)`
   - 소스가 특정 채널에 이벤트 메세지를 발행(Publish)하면, 해당 채널을 구독(Subscribe)한 리스너(Listener)들이 메세지를 받아 이벤트를 처리하는 패턴
   이벤트 소스 (event source), 이벤트 리스너 (event listener), 채널 (channel) 그리고 이벤트 버스 (event bus)의 4가지가 주요 컴포넌트다.
   - WebSocket, Kafka

9. `블랙보드 패턴(Blackboard Pattern)`
   - 모든 컴포넌트들이 공유 데이터 저장소와 블랙보드 컴포넌트에 접근이 가능한 패턴
   - 패턴의 주요 3 컴포넌트는 하위와 같다.
     1. 블랙보드 (blackboard) — 솔루션의 객체를 포함하는 구조화된 전역 메모리
     2. 지식 소스 (knowledge source) — 자체 표현을 가진 특수 모듈
     3. 제어 컴포넌트 (control component) — 모듈 선택, 설정 및 실행을 담당한다
   - 음성 인식, 차량 식별, 신호 해석 등이 그러하며 문제 해결 전략이 정해지지 않을때 유용하다.

10. `인터프리터 패턴(Interpreter Pattern)`
    - 프로그램 코드의 각 라인을 수행하는 방법을 정의하고, 기호마다 클래스를 갖도록 구성된 패턴
    - 특정 언어로 작성된 프로그램을 해석하는 컴포넌트를 설계할 때 사용한다.
    - 번역기, 컴파일러, 인터프리터
     

### Reference
<https://bitcodic.tistory.com/206><br>
<https://mingrammer.com/translation-10-common-software-architectural-patterns-in-a-nutshell/><br>

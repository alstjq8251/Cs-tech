### 소프트웨어 생명 주기(Software Life Cycle) 
`정의`
  - 소프트웨어 생명 주기는 **소프트웨어를 개발하기 위한** 설계, 운용, 유지보수 등의 **과정을 각 단계별로 나눈** 것 이다.
  - 소프트웨어 생명 주기는 소프트웨어 개발 단계와 각 단계별 주요 활동 그리고 활동의 결과에 대한 산출물로 표현한다.

`대표적 생명 주기 모형`
  - 폭포수 모형
  - 프로토 타입 모형
  - 나선형 모형
  - 에자일 모형

a. 폭포수 모형(Waterfall Model)

`정의`
  - 이전 단계로 돌아갈 수 없단 전제하에 **각 단계를 확실히 매듭짓고 그 결과를** 철저하게 **검토하여 승인 과정을 거친 후에**

    **다음 단계를 진행하는 개발 방법론**이다.
  
  - 가장 오래되고 폭넓게 사용된 전통적인 소프트웨어 생명 주기 모형이며 고전적 생명 주기 모형이라고도 한다. (경험과 성공 사례 다수 보유)
  - 각 단계가 끝난 후엔 다음 단계를 수행하기 위한 결과물이 명확하게 산출되어야 한다.

b. 프로토 타입 모형(Prototype Model, 원형 모형)

`정의`
  - **실제 개발될 소프트웨어**에 대한 **견본품(Prototype)을 만들어 최종 결과물을 예측하는 모형**이다.
  - 견본품은 사용자와 시스템 사이의 인터페이스에 중점을 두어 개발한다.

c. 나선형 모형(Spiral Model, 점진적모형)

`정의`
  - 나선을 돌듯 **여러 번의 소프트웨어 개발 과정을 거쳐 점진적으로** 완전한 소프트웨어를 **개발하는 모형**이다.
  - `보헴(Bohem)`이 제안했으며 폭포수 모형과 프로토타입 모형의 장점에 위험 분석 기능을 추가한 모형이다.
  - 누락되거나 추가된 요구사항을 첨가할 수 있고 유지보수 과정이 필요 없다.


<details>
<summary>4가지 주요 활동</summary>
<div>

  - 계획 수립
  - 위험 분석
  - 개발 및 검증
  - 고객 평가 & 반복

</div>
</details>

> 계획하고 분석하고 검증한뒤 평가를 반복

### 에자일 모형(Agile Model)
`정의`
  - 고객의 **요구사항 변화에 유연하게 대응할 수 있도록 일정한 주기를 반복하면서 개발하는 모형**이다.
  - 폭포수 모형과 대조적이며 고객과의 소통에 초점을 춘 방법론을 통칭한다.
    - 폭포수는 각 단계가 끝나면 이전 단계로 돌아갈 수 없지만 에자일은 주기마다 피드백을 수용하는 면에서 대조적
  - 기업 활동 전반에 걸쳐 사용된다.

<details>
<summary>대표적 개발 모형</summary>
<div>

   - 스크럼(Scrum)
   - XP(eXtreme Programming)
   - 칸반(Kanban)
   - Lean
   - 기능 중심 개발(FDD: Feature Driven Development) 

</div>
</details>

`핵심 가치`
  - 프로세스와 도구보단 개인과 상호작용에 더 가치를 둔다.
  - 방대한 문서보다는 실행되는 SW에 더 가치를 둔다.
  - 계약 협상보다는 고객과 협업에 더 가치를 둔다.
  - 계획을 따르기 보다는 변화에 반응하는 것에 더 가치를 둔다.

### 소프트 웨어 공학
`정의`
  - 소프트 웨어 공학(SE: Software Engineering)은 **소프트웨어의 위기를 극복하기 위한 방안으로 연구된 학문**이다.
  - 여러가지 방법론과 도구, 관리 기법을 통해 소프트웨어의 품질과 생산성 향상을 목적으로 한다.

`기본 원칙`
  - 현대적 프로그래밍 기술을 계속적으로 적용해야 한다.
  - 개발된 소프트웨어의 품질이 유지되도록 지속적으로 검증해야 한다.
  - 소프트웨어 개발 관련 사항 및 결과에 대한 명확한 기록을 유지해야 한다.

#### 스크럼(Scrum) 기법
`스크럼의 정의`
  - **팀이 중심이 되어 개발의 효율성을 높이는 기법**이다.

<details>
<summary>스크럼 팀</summary>
<div>

  | 구성원 | 역할 |
  | :--: | :--: |
  | 제품 책임자(PO: Product Owner) | - 요구사항이 담긴 백로그(Backlog)를 작성하는 주체 <br> - 이해관계자들 중 개발될 제품에 대한 이해도가 높고, 요구사항을 책임지고 의사를 결정할 사람으로 선정|
  | 스크럼 마스터(SM: Scrum Master) | - 스크럼 팀이 스크럼을 잘 수행할 수 있도록 가이드 역할을 수행함|
  | 개발팀(DT: Development Team) | 제품 책임자와 스크럼 마스터를 제외한 모든 팀원으로 제품 개발을 수행함|
 
</div>
</details>

<details>
<summary>개발프로세스</summary>
<div>

  | 프로세스 | 내용 |
  | :--: | :--: |
  | 스프린트 계획 회의(Spring Planning Meeting) | 제품 백로그 중 이번 스프린트에서 수행할 작업을 대상으로 단기 일정을 수립하는 회의 | 
  | 스프린트(Sprint) | 실제 개발 작업을 진행하는 과정으로, 보통 2 ~ 4주 정도의 기간 내에서 진행함 |
  | 일일 스크럼 회의(Daily Scrum Meeting) | 모든 팀원이 매일 약속된 시간에 약 15분 동안 진행 사항을 점검하는 회의 <br> 남은 작업 시간은 소멸 차트(Burn-down Chart)에 표시함 | 
  | 스프린트 검토 회의(Sprint review) | 부분 또는 전체 완성 제품이 요구사항에 잘 부합하는지 테스팅하는 회의 |
  | 스프린트 회고(Sprint Retrospective) | 정해놓은 규칙 준수 여부 및 개선할 점을 확인하고 기록하는 것 |
  
</div>
</details>

> **계획**하여 **진행(스프린트)** 한 후 **회의**와 **검토**를 거쳐 **회고**한다.

### XP(eXtreme Programming)
`정의`
  - **고객의 요구사항에 유연하게 대응하기 위해 고객의 참여와 개발 과정의 반복을 극대화하여** 개발 **생산성을 향상시키는 방법**이다.
  - 짧고, 반복적 개발 주기, 단순 설계, 고객의 적극적 참여를 통해 소프트웨어를 빠르게 개발하는 것을 목적으로 한다.
  - 릴리즈의 기간을 짧게 반복하면서 고객의 요구사항 반영에 대한 가시성을 높힌다.


<details>
<summary>XP의 5가지 핵심 가치</summary>
<div>

  - 의사소통(Communication)
  - 단순성(Simplicity)
  - 용기(Courage)
  - 존중(Respect)
  - 피드백(Feedback)
  
</div>
</details>

<details>
<summary>XP 개발 프로세스</summary>
<div>

  | 프로세스 | 내용 |
  | :--: | :--: |
  | 릴리즈 계획 수립(Release Planning) | 부분 , 전체 개발 완료 시점에 대한 일정을 수립하는 것 <br> 몇 개의 스토리가 적용되어 부분적으로 기능이 완료된 제품을 제공하는 것을 릴리즈라고 함|
  | 이터레이션(Iteration , 주기) | 실제 개발 작업을 진행하는 과정으로, 보통 1~3주 정도의 기간으로 진행함|
  | 승인 검사(Acceptance Test, 인수테스트) | 하나의 이터레이션 안에서 부분 완료 제품이 구현되면 수행하는 테스트 |
  | 소규모 릴리즈(Small Release) | 요구사항에 유연하게 대응할 수 있도록 릴리즈의 규모를 축소한 것|

</div>
</details>

<details>
<summary>XP 주요 실천 방법(Practice)</summary>
<div>

  | 실천 방법 | 내용 |
  | :--: | :--: |
  | Pair Programming(짝 프로그래밍) | 다른 사람과 함께 프로그래밍을 수행함으로써 개발에 대한 책임을 공동으로 나눠 갖는 환경을 조성함|
  | Collective Ownership(공동 코드 소유) | 개발 코드에 대한 권한과 책임을 공동으로 소유함 |
  | Test-Driven Development(테스트 주도 개발) | 개발자가 실제 코드를 작성하기 전 테스트 케이스를 먼저 작성함으로 자신이 무엇을 해야할지 정확히 파악함 <br> 테스트가 지속적으로 진행될 수 있도록 자동화된 테스팅 도구(구조, 프레임 워크)를 사용함
  | Whole Team(전체 팀) | 개발에 참여하는 모든 구성원들은 각자 자신의 역할이 있고 그것에 대한 책임을 져야함 |
  | Continous Integration(지속적 통합) | 모듈 단위로 나눠 개발된 코드들은 하나의 작업이 마무리 될때마다 지속적으로 통합됨|
  | Refactoring(리펙토링) | 프로그램 기능 변경 없이 시스템 재구성함 <br> 목적 : 프로그램 쉽게 이해하고 쉽게 수정해 빠르게 개발하기 위해 |
  | small Releases(소규모 릴리즈) | 릴리즈 기간을 짧게 반복함으로써 고객의 요구 변화에 신속히 대응할 수 있음 |
  
</div>
</details>

#### 개발 기술 환경 파악
`개요`
  - 개발하려는 소프트웨어와 관련된 운영체제(OS), DBMS, 미들웨어 등을 산정할 때 고려할 사항을 기술하고, 오픈소스를 사용할 때 주의해야 할 내용을 제시한다.

a. 운영 체제

`정의`
  - **컴퓨터의 시스템 자원을 효율적으로 관리하며**, 사용자가 **컴퓨터를 편리하고 효율적으로 사용할 수 있도록 환경을 제공하는 소프트웨어**이다.

<details>
<summary>운영체제 관련 요구사항 식별 시 고려사항</summary>
<div>

  - 가용성
  - 성능
  - 기술 지원
  - 주변 기기
  - 구축 비용
  
</div>
</details>

b.DBMS

`정의`
  - **사용자와 db사이에서** 사용자의 요구에 따라 **정보를 생성해 주고, 데이터를 관리해 주는 소프트웨어**이다.
  - 기존의 파일 시스템이 갖는 데이터 종속성,중복성등 문제를 해결하기 위해 제안된 시스템

<details>
<summary>DBMS관련 요구사항 식별 시 고려사항</summary>
<div>

  - 가용성
  - 성능
  - 기술 지원
  - 상호 호환성
  - 구축 비용
  
</div>
</details>

c. 웹 어플리케이션(WAS)

`정의`
  - 사용자의 요구에 따라 변하는 **동적인 컨텐츠를 처리하기 위해 사용되는 미들웨어**이다.

<details>
<summary>WAS관련 요구사항 식별 시 고려사항</summary>
<div>

  - 가용성
  - 성능
  - 기술 지원
  - 구축 비용
  
</div>
</details>

d. 오픈 소스

`정의`
  - 별다른 **제한 없이 사용할 수 있도록 소스 코드를 공개한 소프트웨어**이다.

<details>
<summary>오픈소스 관련 요구사항 식별 시 고려사항</summary>
<div>

  - 라이선스의 종류
  - 사용자 수
  - 기술의 지속 가능성
  
</div>
</details>

## 요구사항 정의
`정의`
  - **소프트웨어가 어떤 문제를 해결하기 위해 제공하는 서비스에 대한 설명과** 정상적으로 **운영되는데 필요한 제약조건**이다.

<details>
<summary>요구사항의 유형</summary>
<div>

  - 기능 요구사항(Functional requirements)
  - 비기능 요구사항(Non-functional requirements)
  - 사용자 요구사항(User requirements)
  - 시스템 요구사항(System requirements)
  
</div>
</details>

a. 기능 요구사항(Functional requirements)
  - 시스템이 무엇을 하는지, 어떤 기능을 하는지 등의 **기능이나 수행과 관련된 요구사항**
  - 시스템 입출력에 무엇이 포함되야 하는지, 시스템이 어떤 데이터 저장하거나 연산 수행해야 하는지에 대한 사항

b. 비기능 요구사항(Non-Functional requirements)
  - **품질이나 제약사항과 관련된 요구사항**이다.
  - 성능 요구사항, 제약사항, 인터페이스 요구사항 등

c. 사용자 요구사항(User requirements)
  - **사용자 관점에서 본 시스템이 제공해야 할 요구사항**이다.
    - 사용자를 위함으로 친숙한 표현으로 이해하기 쉽게 작성한다.

d. 시스템 요구사항(System requirements)
  - **개발자 관점에서 본 시스템 전체가** 사용자와 다른 시스템에 **제공해야할 요구사항**이다.
  - 전문적이고 기술적인 용어로 표현되며 소프트웨어 요구사항 이라고도 함

### 요구사항 개발 프로세스
`정의`
  - 개발 대상에 대한 **요구사항을 **체계적으로 **도출하고 분석한 후 명세서에 정리한 다음 확인 및 검증하는** 일련의 구조화된 활동이다.
  - 요구공학(Requirement Engineering)의 한 종류이며 타당성 조사(Feasibility Study)가 선행되어야 한다.

> 도출(Elicitation) -> 분석(Analysis) -> 명세(Specification) -> 확인(Validation)

### 요구사항 도출(Requirement Elicitation, 요구사항 수집)
`정의`
  - 시스템, 사용자, 개발자 등 **시스템 개발에 관련된 사람들이 서로 의견을 교환하여 요구사항**을 어떻게 수집할 것인지 **식별하고 이해하는 과정**이다. 

<details>
<summary>요구사항을 도출하는 주요 기법</summary>
<div>

  - 청취와 인터뷰
  - 설문
  - 브레인 스토밍
  - 워크샵
  - 프로토타이핑
  - 유스케이스
  
</div>
</details>

### 요구사항 분석(Requiremnt Analysis)
`정의`
  - 개발 대상에 대한 사용자의 **요구사항 중** 명확x , 모호하여 **이해되지 않는 부분을** 발견하고 이를 **걸러내기 위한 과정**이다.
  - **개발 대상에 대한 사용자의 요구사항을 이해하고 문서화 하는 활동**을 의미한다.

### 구조적 분석 기법
`정의`
  - **자료의 흐름과 처리를 중심으로 하는 요구사항 분석 방법**이다.
  - 하향식 방법을 사용해 시스템을 세분화 할 수 있고 분석의 중복을 배제할 수 있다.

<details>
<summary>주요 구조적 분석 기법 도구</summary>
<div>

  - 자료 흐름도(DFD)
  - 자료 사전(DD)
  - 소단위 명세서(Mini-spec)
  - 개체 관계도(ERD)
  - 상태 전이도(STD)
  - 제어 명세서
  
</div>
</details>

a. 자료 흐름도

`정의`  
  - **자료의 흐름 및 변환 과정과 기능을 도형 중심으로 기술하는 방법**이다.

<details>
<summary>자료 흐름도 기본 기호</summary>
<div>

  | 기호 | 의미 | 표기법(Yourdon/Demacro) | 표기법(Gane/Sarson) |
  | :--: | :--: | :--: | :--: |
  | 프로세스(Process) | 자료를 변환시키는 시스템의 한 부분(처리 과정)을 나타내며 처리, 기능, 변환, 버블이라고도 함 | O | ㅁ |
  | 자료 흐름(Data flow) | 자료의 이동(흐름)이나 연관관계를 나타냄 | -> | -> |
  | 자료 저장소(Data store) | 시스템에서의 자료 저장소(파일,데이터베이스)를 나타냄) | 칼럼식 | pk와 칼럼 같이 표현 |
  | 단말(Terminator) | 시스템과 교신하는 외부 개체로, 입력 데이터가 만들어지고 출력 데이터를 받음 | ㅁ | ㅁㅁ|
  
</div>
</details>

b. 자료 저장소(DD: Data Dictionary)

`정의`
  - **자료 흐름도에 있는 자료를** 더 자세히 **정의하고 기록한 것**이다.

<details>
<summary>표기 기호</summary>
<div>

  | 기호 | 의미 | 
  | :--: |  :--: |
  | = | `자료의 정의` : ~로 구성되어 있다(is composed of) |
  | + | `자료의 연결` : 그리고(and)|
  | ( ) | `자료의 생략` : 생략 가능한 자료(Optional)|
  | [] | `자료의 선택` : 또는(or) |
  | {} | `자료의 반복` : Iteraition of |
  | * * | `자료의 설명` : 주석(Comment) |
  
</div>
</details>

##### CASE and HIPO
`CASE`
  - **요구사항을 자동으로 분석하고 요구사항 분석 , 명세서를 기술하도록 개발된 도구**

`HIPO`
  - **시스템 실행 과정인 입력 처리 출력의 기능을 표현한 것**이다.


### 요구사항 명세(Requirement Specification)
`정의`
  - **분석된 요구사항을 바탕으로 모델을 작성하고 문서화하는 것**을 의미한다.
  - 기능 요구사항 전부, 비기능 요구사항 필요한 것만 기술한다.

### 요구사항 확인(Requirement Validation, 요구사항 검증)
`정의`
  - **요구사항 명세서가 정확하고 완전하게 작성되었는지를 검토하는 활동**이다.
  - 요구사항 관리 도구를 이용해 요구사항 정의 문서들에 대해 형상 관리(scm)를 수행한다.

### 요구공학(Requirement Engineering)
`정의`
  - **요구사항을 정의하고, 분석 및 관리하는 프로세스를 연구하는 학문**이다.

### 요구사항 명세 기법
<details>
<summary>요구사항 명세 기법</summary>
<div>

  |구분|정형 명세 기법 | 비정형 명세 기법 |
  | :--: | :--: | :--: |
  | 기법 | 수학적 원리 기반, 모델 기반 | 상태/기능/객체 중심|
  | 작성 방법 | 수학적 기호, 정형화된 표기법 | 일반 명사, 동사 등 자연어를 기반으로 서술, 다이어그램으로 작성|
  | 특징 | 요구사항을 정확하고 간결하게 표현할 수 있음 <br> 요구사항에 대한 결과가 작성자에 관계없이 일관성이 있으므로 완전성 검증이 가능 <br> 표기법이ㅣ 어려워 사용자가 이해하기 어려움 | 자연어의 사용으로 인해 요구사항에 대한 결과가 작성자에 따라 다를 수 있어 일관성 떨어지고 해석 달라질 수 있음 <br> 내용의 이해가 쉬워 의사소통이 용이함|
  | 종류 | VDM, Z, Petri-net, csp | FSM, Decision Table, ER모델링, State Chart(SADT)등|
  
</div>
</details>

### UML(Unified Modeling Language)
`정의`
  - **시스템 개발 과정에서** 시스템 개발자와 고객 또는 개발자 상호 간의 **의사소통이 원활하게 이루어지도록 표준화한**

    **대표적인 객체지향 모델링 언어**이다.
    
  - Rumbaugh(OMT), Booch, Jacobson 등 객체지향 방법론의 장점을 통합했다.

<details>
<summary>UML의 구성 요소</summary>
<div>

  - 사물(Things)
  - 관계(Relationships)
  - 다이어그램(Diagram)
  
</div>
</details>

a. 사물

`정의`
  - **다이어그램 안에서 관계가 형성될 수 있는 대상들**을 말한다.

<details>
<summary>사물의 종류</summary>
<div>

  | 사물 | 내용 |
  | :--: | :--: | 
  | 구조 사물<br>(Structural Things) | 시스템의 개념적, 물리적 요소를 표현 <br> 클래스, 유스케이스ㅡ 컴포넌트, 인터페이스, 노드 등 |
  | 행동 사물<br>(Behavioral Things) | 시간과 공간에 따른 요소들의 행위를 표현 <br> 상호 작용(Interaction) , 상태 머신(State Machine) |
  | 그룹 사물<br>(Grouping Things) | 요소들을 그룹으로 묶어서 표현 <br> 패키지 |
  | 주해 사물<br>(Annotation Things) | 부가적 설명이나 제약조건 등을 표현 <br> 노트 |
  
  
</div>
</details>

b. 관계

`정의`
  - **사물과 사물 사이의 연관성을 표현하는 것**이다.

<details>
<summary>관계의 종류</summary>
<div>
  
   - 연관 관계
   - 집합 관계
   - 포함 관계
   - 일반화 관계
   - 의존 관계
   - 실체화 관계
  
</div>
</details>

`연관(Association) 관계`
  - **2개 이상의 사물이 서로 관련되어 있는 관계**이다.
  - 사물 사이를 실선으로 연결하여 표현하며 방향성은 화살표로 표현한다.
  - 양방향 관계의 경우 화살표를 생략하고 실선으로만 연결한다.

<details>
<summary>사물의 종류</summary>
<div>

  | 다중도 | 의미 |
  | :--: | :--: |
  | 1 | 1개의 객체가 연관되어 있음 |
  | n | n개의 객체가 연관되어 있음 |
  | 0.1 | 연관된 객체가 없거나 1개만 존재함 |
  | 0.* , * | 연관된 객체가 없거나 다수일 수 있음 |
  | 1.* | 연관된 객체가 적어도 1개 이상 |
  | n.* | 연관된 객체가 적어도 n개 이상 |
  | n.m | 연관된 객체가 최소 n개에서 최대 m개임|
  
</div>
</details>

`집합(Aggregation) 관계`
  - **하나의 사물이 다른 사물에 포함되어 있는 관계**이다.
  - 포함 관계의 두 객체는 서로 독립적이며 포함 되는 쪽(Part)에서 포함 하는 쪽(Whole)로 속 빈 마름모 화살표 연결

`포함(Composition) 관계`
  - **포함하는 사물의 변화가 포함되는 사물에게 영향을 미치는 관계**
  - 포함 관계의 두 객체는 독립적이지 않고 생명주기를 함께 함
  - 집합 관계와 달리 속이 채워진 마름모로 포함되는 쪽에서 포함하는 족으로 연결

`일반화(Generalization) 관계`
  - **하나의 사물이 다른 사물에 비해 더 일반적이거나 구체적인 관계**이다.
  - 추상화와 비슷하며 구체적인(하위)사물에서 일반적(상위)인 사로 속빈 화살표로 표현

`의존(Dependency) 관계`
  - 연관 관계와 같이 서로 연관은 있으나 필요에 의해 **서로에 영향을 주는 짧은 시간 동안만 연관을 유지하는 관계**이다.
  - 소유 관계는 아니지만 변화가 서로에게 영향을 주며 영향 받는 쪽이 영향을 주는 쪽으로 점선 화살표 표시

`실체화(Realization) 관계` 
  - **할 수 있거나 해야 하는 기능으로, 서로를 그룹화 할 수 있는 관계이다.**
  - 상위 객체로 속 빈 점선 화살표 표시

c. 다이어그램

`정의`
  - **사물과 관계를 도형으로 표현한 것**이다.
  - 정적 모델링에서는 구조적 다이어그램을 동적 모델링에서는 행위 다이어그램을 사용한다.

<details>
<summary>구조적 다이어그램 종류</summary>
<div>

  | 종류 | 내용 |
  | :--: | :--: |
  | 클래스 다이어그램 <br> (Class Diagram) | 클래스와 클래스가 가지는 속성, 클래스 사이의 관계를 표현 |
  | 객체 다이어그램 <br> (Object Diagram) | 클래스에 속한 사물(객체)들, 즉 인스턴스를 특정 시점의 객체와 객체 사이 관계로 표현 <br> 럼바우 객체지향 분석 기법에서 객체 모델링에 활용됨|
  | 컴포넌트 다이어그램 <br> (Component Diagram) | 실제 구현 모듈인 컴포넌트 간의 관계나 컴포넌트 간의 인터페이스를 표현 <br> 구현 단계에서 사용 |
  | 배치 다이어그램 <br> (Deployment Diagram) | 결과물, 프로세스, 컴포넌트 등 물리적 요소들의 위치를 표현 <br> 구현 단계에서 사용 | 
  | 복합체 구조 다이어그램 <br> (Composite Structure Diagram) | 클래스나 컴포넌트가 복합 구조를 갖는 경우 그 내부 구조를 표현함 | 
  | 패키지 다이어그램 <br> (Package Diagram) | 유스케이스나 클래스 등의 모델 요소들을 그룹화한 패키지 들의 관계를 표현 |
  
</div>
</details>

<details>
<summary>행위 다이어그램 종류</summary>
<div>

  | 종류 | 내용 |
  | :--: | :--: |
  | 유스케이스 다이어그램 <br> (Use case Diagram) | 사용자의 요구를 분석하는 것으로, 기능 모델링 작업에 사용함 <br> 사용자(Actor)와 사용 사례(Use case)로 구성됨 |
  | 순차 다이어그램 <br> (Sequence Diagram) | 상호 작용하는 시스템이나 객체들이 주고받는 메세지를 표현함|
  | 커뮤니케이션 다이어그램 <br> (Communication Diagram) | 동작에 참여하는 객체들이 주고는 메세지와 객체들 간의 연관 관계를 표현함 |
  | 상태 다이어그램 <br> (State Diagram) | 하나의 객체가 자신이 속한 클래스의 상태 변화, 다른 객체간 상호 작용에 따라 상태가 어떻게 변하는지 표현 <br> 럼바우 객체지향 분석 기법에서 동적 모델링에 활용됨| 
  | 활동 다이어그램 <br> (Activity Diagram) | 시스템이 어떤 기능을 수행하는지 객체의 처리 로직이나 조건에 따른 처리 흐름을 순서에 따라 표현 | 
  | 상호 작용 개요 다이어그램 <br> (Interaction Overview Diagram) | 상호작용 다이어그램 간의 제어 흐름을 표현함 |
  | 타이밍 다이어그램 <br> (Timing Diagram) | 객체 상태 변화와 시간 제약을 명시적으로 표현함 |
  
</div>
</details>

d. 스테레오 타입
  - **UML에서 표현하는 기본 기능 외에 추가적인 기능을 표현**하는 것이다.
  - 길러멧(Guilemet)이라고 부르는 겹화살괄호(<<>>) 사이에 표현할 형태를 기술한다.

<details>
<summary>주로 표현하는 형태</summary>
<div>

  | 표현 형태 | 의미 |
  | :--: | :--: |
  | << include >> | 연결된 다른 UML 요소에 대해 포함 관계에 있는 경우 |
  | << extends >> | 연결된 다른 UML 요소에 대해 확장 관계에 있는 경우 |
  | << interface >> | 인터페이스를 정의하는 경우 |
  | << exception >> | 예외를 정의하는 경우 |
  | << constructor >> | 생성자 역할을 수행하는 경우 |
  
</div>
</details>

#### 기능 모델링
 - **개발될 시스템이 갖춰야 할 기능을** 정리한 후 **사용자**와 함께 정리된 내용을 **공유하기 위해 그림으로 표현 하는 것** 이다.
 - 유스케이스 다이어그램 , 활동 다이어그램이 속한다.

a. 유스케이스 다이어그램
  -  **개발될 시슽템을 이용해 수행할 수 있는 기능을 사용자의 관점에서 표현한 것**이다

b. 활동 다이어그램
  - **사용자의 관점에서 시스템이 수행하는 기능을 처리 흐름에 따라 순서대로 표현한 것**이다.
  
## 정적 모델링
  - **사용자가 요구한 기능을 구현하는데 필요한 자료들의 논리적인 구조를 표현한 것**이다.
  - 객체들을 클래스로 추상화하여 표현하고 UML을 이용한 정적 모델링의 대표적인 것이 클래스 다이어그램이다.

### 동적 모델링
  - **시스템의 내부 구성 요소들의 상태 변화 과정과 과정에서 발생하는 상호 작용을 표현한 것**이다.
  - 시스템 내부 구성 요소들 간에 이루어지는 동작이라는 관점(View)에서 표현한다.
  - 시스템이 실행될 때 구성 요소들 간 메세지 호출, 오퍼레이션을 통한 상호 작용에 초점을 둔다.


<details>
<summary>동적 모델링 종류</summary>
<div>

  - 순차 다이어그램
  ![image](https://github.com/alstjq8251/Cs-tech/assets/98382954/27f9d395-79be-41a0-931d-887368f0b7d6)

  - 커뮤니케이션 다이어그램
  - 상태 다이어그램
  
</div>
</details>

#### 소프트웨어 개발 방법론
  - **소프트웨어 개발, 유지보수 등에 필요한** 여러 일들의 **수행 방법과** 이런 일들을 효율적으로 수행하려는 과정에서 발생한

    **각종 기법 및 도구를 체계적으로 정리하여 표준화한 것**이다.
    
<details>
<summary>주요 소프트웨어 개발 방법론</summary>
<div>
  
  - 구조적 방법론
    - 정형화된 분석 절차에 따라 **사용자 요구사항을 파악하여 문서하는 처리(Process) 중심의 방법론**이다.
    - 1960년대까지 가장 많이 사용됐으며 복잡한 문제를 다루기 위해 분할과 정복 원리를 적용한다.
    - `개발 절차` 타당성 검토 -> 계획 -> 요구사항 -> 설계 -> 구현 -> 시험 -> 운용/유지보수
  - 정보공학 방법론
    - 정보 시스템 개발을 위해 **계획, 분석, 설계, 구축에 정형화된 기법들을** 상호 연관성 있게 
  
      **통합 및 적용하는 자료(Data)중심의 방법론**이다.
    - `개발 절차` 정보 전략 계획 수립 -> 업무 영역 분석 -> 업무 시스템 설계 -> 업무 시스템 구축 ->
  - 객체지향 방법론
    - 소프트웨어를 개발할 때 기계 부품 조립하듯 **객체들을 조립해서** 필요한 **소프트웨어를 구현하는 방법론**이다.
    - `구성요소` : 객체 , 클래스 , 메세지 등
    - `기본 원칙` : 캡슐화, 정보은닉, 추상화, 상속성, 다형성 등
    - `개발 절차` : 요구 분석 -> 설계 -> 구현 -> 테스트 및 검증 -> 인도
  - 컴포넌트 기반(CBD) 방법론
    - 기존 시스템, 소프트웨어를 구성하는 **컴포넌트를 조합해** 하나의 **새로운 어플리케이션을 만드는 방법론**이다.
    - 컴포넌트의 재사용을 통해 시간 노력 절감, 확장성 보장, 유지 보수 비용 최소화 및 생산성 및 품질을 향상시킨다.
    - `개발 절차` : 개발 준비 -> 분석 -> 설계 -> 구현 -> 테스트 -> 전개 -> 인도
  - 제품 계열 방법론
    - 특정 **제품에 적용하고 싶은 공통된 기능을 정의하여 개발하는 방법론**이다.
    - 임베디드 소프트웨어를 만드는데 적합하다
  - 에자일 방법론
  
</div>
</details>

### S/W 공학의 발전적 추세
a. 소프트웨어 재사용
  - **이미 개발돼 인정받은 소프트웨어를 다른 소프트웨어 개발이나 유지에 사용하는 것**이다.

<details>
<summary>재사용 방법</summary>
<div>
  
  - 합성 중심(Composition-Based) : 전자 칩등 SW부품, 블록을 만들어 끼워 맞춰 소프트웨어를 완성 시키는 방법으로 블록 구성 방법이라고도함
  - 생성 중심(Generation-Based) : 추상화 형태로 써진 명세를 구체화해 프로그램을 만드는 방법으로 패턴 구성 방법이라고도 한다.
  
</div>
</details>

b. 소프트웨어 재공학(Software Reengineering)
  - **기존 시스템을 이용해 나은 시스템을 구축하고, 새로운 기능 추가해 소프트웨어 성능 향상시키는 것**이다.
  - 유지보수의 생상성 향상을 통해 소프트웨어 위기를 해결하는 방법으로 개조 및 개선을 통해 유지보수성, 품질을 향상시킨다.

<details>
<summary>재공학 이점</summary>
<div>

  - 소프트웨어의 품질 향상
  - 소프트웨어의 생상성 증가
  - 소프트웨어의 수명 연장
  - 소프트웨어의 오류 감소
  
</div>
</details>

##### 비용 산정 기법(하향식)
  - **과거의 유사한 경험을 바탕으로 전문 지식이 많은 개발자들이 참여한 회의를 통해 비용을 산정하는** 비과학적 방법이다.
  - 전문가 감정 기법
    - **경험 많은 두 명 이상 전문가에게 비용 산정 의뢰하는 기법**이다.
  - 델파이 기법
    - **전문가 감정 기법의 주관성을 보완하기 위해 많은 전문가의 의견을 종합해 산정하는 기법이다.**

## 비용 산정 기법(상향식)
  - 프로젝트의 **세부 작업 단위별로 비용을 산정 후 집계해 전체 비용을 산정하는 방법이다.**

a. LOC(원시 코드 라인 수, source Line of Code)기법
  - **각 기능의 원시 코드 라인 수의 비관치, 낙관치 , 기대치를 측정해 예측치를 구하고 이를 이용해 비용을 산정하는**기법이다.
  - 예측치를 이용해 생산성,노력,개발 기간등의 비용을 산정한다.
    - 예측치 = a+4m+b/6 ( a : 낙관치 , b : 비관치 , m : 기대치(중간치))
  - <details>
    <summary>산정 공식</summary>
    <div>

      - 노력 = 개발 기간 x 투입 인원 x LOC/1인당 월 평균 생산 코드 라인 수 
      - 개발 비용 = 노력 x 단위 비용(1인당 월평균 인건비)
      - 개발 기간 = 노력 x 투입 인원
      - 생산성 = LOC / 노력

    </div>
    </details>

b. 개발 단계별 인원수(Effort per Task)기법
  - LOC기법을 보완하기 위한 것으로 각 **기능을 구현시키는데 필요한 노력을 생명 주기의 각 단계별로 산정**한다.

c. 수학적 산정 기법
  - 경험적 추정 모형, 실험적 추정 모형이라고함
  - 개발 비용 산정의 자동화를 목표로 한다.

c-1. COCOMO(COnstructive COst MOdel)모형
  - **LOC에 의한 비용 산정 기법**이다.
  - 보헴(Bohem)이 제안했으며 비용 산정 결과는 프로젝트에 필요한 노력(Man-Month)로 나타낸다.
  - <details>
    <summary>개발 유형</summary>
    <div>

      | 유형 | 특징 |
      | :--: | :--: |
      | 조직형 <br> (Organic Model) | 기관 내부에서 개발된 중,소 규모 <br> 약 5만 라인 이하의 소프트웨어를 개발하는 유형 <br> 사무처리용 업무, 과학용 소프트웨어 개발에 적합 |
      | 반 분리형 <br> (Semi-Detached Model) | 조직형, 내장형 중간 규모 <br> 30만 라인 이하의 소프트웨어를 개발하는 유형 <br> 컴파일러, 인터프리터 같은 유틸리티 개발에 적합|
      | 내장형 (Embedded Model) | 초대형 규모로 30만 라인 이상의 소프트웨어 개발의 유형 <br> 신호기 제어, 미사일 유도시스템 등 시스템 프로그램 개발에 적합 |
      
    </div>
    </details>
    
  - <details>
    <summary>모형 종류</summary>
    <div>

      | 유형 | 특징 |
      | :--: | :--: |
      | 기본형(basic) <br> COCOMO  | 소프트웨어 크기, 개발 유형만을 이용해 비용 산정 |
      | 중간형(Intermediate) <br> COCOMO | 기본형의 공식을 토대로 하나 4가지 특성에 의해 비용 산정 <br> 1. 제품 특성 <br> 2. 컴퓨터 특성 <br> 3. 개발 요원 특성 <br> 4. 프로젝트 특성 |
      | 발전형(Detailed) <br> COCOMO | 중간형을 보완해 만들어졌으며 개발 공정별로 자세하고 정확하게 노력 산출해 비용 산정 <br> 환경과 구성 요소가 사전에 정의되어 있어야 하며 개발 과정 후반부에 적용함 |
      
    </div>
    </details>
    
c-2. Putnam 모형
  - **소프트웨어 생명 주기의 전 과정 동안에 사용될 노력의 분포를 예상하는 모형**이다.
  - 대형 프로젝트 노력 분포 산정에 이용되며 시간에 따른 함수로 표현되는 Rayleigh-Norden 곡선의 노력 분포도를 기초로 한다.

c-3. 기능 점수(FP: Function Point) 모형
  - **소프트웨어의 기능을 증대시키는 요인별**로 가증치 부여, 요인별 가증치 합산해 총 기능 점수 산출하고 영향도를 이용해 **기능 점수(FP)를 구한 후** 비용 산출하는 기법
  - 알브레히트(Albrecht)가 제안했다.
  - <details>
    <summary>기능 증대 요인</summary>
    <div>

      - 자료 입력(입력 양식)
      - 정보 출력(출력 보고서)
      - 명령어(사용자 질의수)
      - 데이터 파일
      - 필요한 외부 루틴과의 인터페이스

    </div>
    </details>
    
`SLIM` 
  - Rayleigh-norden 곡선과 Putnam 예측 모델 기초로 해 개발된 자동화 추정 도구
`ESTIMACS`
  - 다양한 프로젝트와 개인별 요소를 수용하도록 FP 모형을 기초로해 개발된 자동화 추정 도구

### 프로젝트 일정 계획
  - 프로젝트의 프로세스를 이루는 소작업 파악해 예측된 노력을 각 소작업에 분배해 순서와 일정을 정하는 것

a. PERT(Program Evaluation and Review Technique, 프로그램 평가 및 검토 기술)
  - **전체 작업의 상호 관계를 표시하는 네트워크**이다.
  - 작업별 (낙관, 가능성이 있는 , 비관)의 경우에서 단계롤 나누어 종료 시기 결정한다.
  - 노드와 간선으로 구성돼 원 노드엔 작업 간선엔 낙관치, 기대치, 비관치를 표시한다.
  - 작업 예측치 = 비관치+4x기대치 +낙관치/6 , 평방 편차 = [(비관치-낙관치)/6]2승

b. CPM(Critical Path Method, 임계 경로 기법)
  - 프로젝트 완성에 필요한 **작업을 나열하고 작업에 필요한 소요 기간을 예측하는데 사용하는 기법**이다.
  - 원형 노드는 각각의 작업을 박스 노드는 이정표를 의미하며 간선은 작업 사이의 의존 관계를 나타낸다.

c. 간트차트
  - **프로젝트**의 각 작업이 언제 시작되고 종료되는지 **작업 일정을 막대 도표를 이용해 표시하는 프로젝트 일정표**이다.
  - 시간선(Time-line Chart)라고도 한다.

#### 소프트웨어 개발 방법론 결정
  - 프로젝트 관리, 재사용 현황을 소프트웨어 개발 방법론에 반영하고 확정된 소프트웨어 생명 주기, 개발 방법론에 맞춰

    개발 단계, 활동, 작업, 절차 등을 정의하는 것이다.
    
  - <details>
    <summary>절차</summary>
    <div>

      1. 프로젝트 관리, 재사용 현황 소프트웨어 개발 방법론에 반영
      2. 개발 단계별 작업, 절차를 소프트웨어 생명 주기에 맞춰 수립
      3. 결정된 소프트웨어 개발 방법론의 각 단계별 활동 목적, 작업 내용, 산출물에 대한 메뉴얼 작성
      
    </div>
    </details>  
    
  - <details>
    <summary>프로젝트 관리(PM)</summary>
    <div>
      
      - **최소의 비용으로** 사용자를 만족시키는 **시스템을 개발하기 위한 전반적인 활동**이다.

      |관리 유형 | 주요 내용 |
      | :--: | :--: | 
      | 일정 관리 | 작업 순서, 작업 기간 등 |
      | 비용 관리 | 비용 산정, 비용 예산 편성 |
      | 인력 관리 | 팀 편성, 자원 산정, 조직 정의 , 팀 개발, 자원 통제, 팀관리 |
      | 위험 관리 | 위험 식별, 위험 평가 , 대처, 통제 |
      | 품질 관리 | 품질 계획, 품질 보증 수행, 품질 통제 수행 |
      
    </div>
    </details>   
    
### 소프트웨어 개발 표준
  - **소프트웨어 개발 단계에서 수행하는 품질 관리에 사용하는 국제 표준**을 의미한다.

a. ISO/IEC 12207
  - **ISO(국제표준화기구)ㅇ서 만든 표준 소프트웨어 생명 주기 프로세스**이다.
  - <details>
    <summary>구분</summary>
    <div>
     
      `기본 생명 주기 프로세스` : 획득 , 공급 , 개발 , 운영 , 유지보수 프로세스
      `자원 생명 주기 프로세스` : 품질 보증, 검증, 확인, 활동 검토, 감사, 문서화, 형상 관리, 문제 해결 프로세스
      `조직 생명 주기 프로세스` : 관리, 기반 구조, 훈련 개선 프로세스
      
    </div>
    </details> 
    
b. CMMI(Capability Maturity Model Integration)
  - **소프트웨어 개발 조직의 업무 능력 및 조직의 성숙도를 평가하는 모델**이다.
  - <details>
    <summary>성숙도</summary>
    <div>
     
      | 단계 | 프로세스 | 특징 |
      | :--: | :--: | :--: |
      | 초기 | 정의된 프로세스 없음 | 작업자 능력에 따라 성공 여부 결정 |
      | 관리(managed) | 규칙화된 프로세스 | 특정 프로젝트 내 프로세스 정의 및 수행 |
      | 정의(Defined) | 표준화된 프로세스 | 조직 표준 프로세스 활용해 업무 수행 |
      | 정량 관리 | 예측 가능 프로세스 | 프로젝트를 정량적 관리 및 통제 |
      | 최적화 | 지속 개선 프로세스 | 프로세스 역량 향상을 위해 지속적 프로세스 개선|
      
    </div>
    </details> 
    
c. SPICE(Software Process Improvement and Capability dEtermination)
  - **소프트웨어의 품질 및 생산성 향상을 위해 소프트웨어 프로세스를 평가 및 개선하는 국제 표준**이다.
  - ISO/IEC 15504
  - <details>
    <summary>수행 단계</summary>
    <div>
     
      | 단계 | 특징 |
      | :--: | :--: |
      | 불완전(Incomplete) | 프로세스 구현되지 않았거나 목적 달성하지 못한 단계 |
      | 수행(performed) | 프로세스 수행되고 목적이 달성된 단계 |
      | 관리(Managed) | 정의된 자원 한도 내 프로세스가 작업 산출물 인도 하는 단계 |
      | 확립(Established) | 소프트웨어 공학 원칙에 기반 정의된 프로세스 수행하는 단계 |
      | 예측(Predicatable) | 프로세스가 목적 달성을 위해 통제되고, 양적 측정을 통해 일관되게 수행하는 단계 |
      | 최적화(Optimizing) | 프로세스 수행 최적화하고, 지속적 개선 통해 업무 목적을 만족시키는 단계 |
      
    </div>
    </details> 
    
#### 소프트웨어 개발 방법론 테일러링
  - **소프트웨어 개발 방법론의 절차 , 사용기법 등을 수정 및 보완하는 작업**이다.
  - 수행 절차
    - 프로젝트 특징 정의 -> 표준 프로세스 산정 및 검증 -> 상위 수준의 커스터마이징 -> 세부 커스터마이징 -> 테일러링 문서화
  - <details>
    <summary>고려 사항</summary>
    <div>
     
      | 기준 | 내용 |
      | :--: | :--: |
      | 내부적 기준 | 목표 환경, 요구 사항, 프로젝트 규모, 보유 기술 |
      | 외부적 기준 | 법적 제약사항, 표준 품질 기준|
      
    </div>
    </details> 
    
### 소프트웨어 개발 프레임워크 
  - **소프트웨어 개발에 공통적으로 사용되는 구성 요소와 아키텍처를 일반화하여** 손쉽게 구현하도록 여러가지 기능을 제공하는

    **반제품 형태의 소프트웨어 시스템 이다.**

  - <details>
    <summary>주요 기능</summary>
    <div>

      - 예외 처리
      - 트랜잭션 처리
      - 메모리 공유
      - 데이터 소스 관리
      - 서비스 관리
      - 쿼리 서비스
      - 로깅 서비스
      - 사용자 인증 서비스
      
    </div>
    </details> 

a. 스프링
  - **자바 랫폼을 위한 오픈 소스 경량형 어플레키에션 프레임워크** 이다.

b. 전자 정부 프레임워크
  - **대한민국 공공부문 정보화 사업 시** 효율적인 **정보 시스템 구축을 지원**하기 위해 필요한 

    **기능 및 아키텍처를 제공하는 프레임워크**이다.
    
c. 닷넷 프레임워크(.NET Framework)
  - **Windows 프레임워크의 개발 및 실행 환경을 제공하는 프레임워크**이다.
  - 코드 실행 관리하는 CLR(Common Language Runtime)이라는 이름의 가상머신 상에서 작동한다.

<details>
<summary>주요 기능</summary>
<div>

  | 특성| 내용 |
  | 모듈화 | 캡슐화를 통해 모듈화 강화, 설계 및 구현의 변경에 따른 영향을 최소화해 품질 강화-> 유지보수 용이 |
  | 재사용성 | 재사용 가능한 모듈을 제공해 예산 절감, 생산성 향상, 품질 보증 |
  | 확장성 | 다형성(Ploymorphism)을 통한 인터페이스 확장이 가능해 다양한 형태의 기능을 가진 어플리케이션 개발이 용이 |
  | 제어의 역흐름 | 개발자가 관리하고 통제하는 객체들의 제어를 프레임워크에 맡겨 생산성 향상|
  
</div>
</details> 

### Context란?
- 프로세스 context는 프로세스가 현재 어떤 상태에서 수행되고 있는지 정확히 규명하기 위해 필요한 정보를 말한다.

```
현대의 운영체제는 다중 프로세스가 동작하는 시분할 시스템 환경이다.
시분할 시스템 환경에서는 타이머 인터럽트에 의해 짧은 시간동안 CPU를 점유하고 다른 프로세스에게 넘겨주고 다시 차례가 되면 CPU를 점유하여 명령을 수행한다.
명령을 다시 수행하기 위해선 이전에 어디까지 명령을 수행했는지 정확한 수행 시점과 상태를 재현할 수 있는 정보가 필요했는데 그 정보가 바로 프로세스 문맥(process context)이다.
```

프로세스의 문맥은 다음과 같은 3가지 부분으로 나눌 수 있다.
1. 하드웨어 문맥
  - CPU 수행 상태를 나타내는 것으로 PC(Program Counter) 와 각종 레지스터에 저장하고 있는 값 
2. 프로세스의 주소 공간
  - 코드, 데이터, 스택 으로 구성된 프로세스만의 독자적인 주소 공간을 말한다. 
3. 커널상의 문맥
  - 프로세스를 관리를 위한 자료구조인 PCB(Process Control Block)와 Kernel stack(커널내의 주소)을 말한다.

PCB에 대한 설명은 하단의 페이지에서 기술되어 있다.
~~추후 기술후 기재 예정~~

<img width="100%" alt="image" src="https://user-images.githubusercontent.com/98382954/227759822-bcfe317e-6a90-46d4-8a6d-ccb23d154ba1.png">


### ContextSwitching 이란?
```
문맥(context)은 프로세스의 상태 정보를 의미한다.
문맥 교환(context switch)은 프로세스의 상태 정보를 교환하는 작업을 의미한다.
문맥 교환이란 하나의 프로세스가 CPU를 사용 중인 상태에서 다른 프로세스가 CPU를 사용하도록 하기 위해 이전의 프로세스의 상태를 
PCB에 보관하고 또 다른 프로세스의 정보를 PCB에서 읽어 레지스터에 적재하는 과정이다.
```

`ContextSwitching`
  - 사용자 프로세스로부터 다른 사용자 프로세스로 CPU의 제어권이 이양되는 과정을 말한다.
  - 프로세스(A)가 입출력을 요청해야 하는 경우가 생겼다고 가정했을 때, 입출력을 하기 위해서 프로세스는 I/O를 요청하는 시스템 콜을 발생시키고, 
  
    프로세스는 Device Queue에 줄을 서게 되고 준비 상태로 상태가 변경됩니다.
      - 해당 프로세스의 상태 전이는 Proccess Thread.md에서 확인할 수 있다.
  - 준비 큐에 있던 다른 프로세스(B)가 CPU를 할당받아 명령을 수행하게 될 것인데 이때 CPU의 제어권이 넘어가는걸 문맥 교환이라고 한다.
  - 문맥 교환 시점에 리소스 , 시간 등을 시스템 입장에서 오버헤드라고 볼 수 있는데  타이머 인터럽트 시간을 너무 짧게하면 프로세스간 문맥 교환이
  
     너무 자주 일어나 오버헤드가 커지게 되므로 적절하게 지정할 필요가 있다.
     
> 프로세스간 I/O 시스템 콜 외에 프로세스의 봉쇄 상태에서도 문맥 교환 과정은 발생할 수 있는데 프로세스가 CPU를 사용하다가 I/O 작업을 하게 되는 경우 <br>
> CPU를 사용하지 않게 되므로 이런 경우 CPU 낭비가 되기 때문에 다른 프로세스에게 CPU를 이양한다.

<img width="100%" alt="image" src="https://user-images.githubusercontent.com/98382954/227758486-07555822-ef30-4669-9915-c671f8d9b463.png">

##### Process마다 Context를 가지는 이유?
- 문맥교환이 일어나기 때문인데 문맥 교환 중 CPU를 선점하고 있던 프로세스는 프로세스 문맥을 자신의 PCB에 저장하게 되고, 

  새롭게 CPU를 할당 받을 프로세스는 PCB로부터 예전에 저장했던 자신의 문맥을 실제 하드웨어로 복원시키는 과정을 거치게 된다.

#### Context Switching을 하는 이유?
```
 CPU는 한 번에 하나의 프로세스만 수행할 수 있는데 기술에 발전에 따라 사용자는 여러 개의 프로세스를 동시에 수행하려고 한다.
 CPU는 동시에 수행하는 처럼 보이게 하기 위해서 여러 개의 프로세스를 번갈아가며 수행한다.
 이러한 문맥 교환 과정이 없다면 단일 프로세스 및 쓰레드가 cpu의 모든 자원을 독점하기 때문에 다른 프로그램이나 쓰레드는 실행되지 못한다.
 문맥 교환은 복잡한 작업이며 자주 발생하는 경우 오버헤드가 커질 수 있어 오버헤드를 최소화하고 작업의 우선순위를 지정하는 것이 주요하다.
   문맥 교환을 하는 시점엔 프로세스 , 쓰레드가 실행될 수 없기 때문에 문맥 교환에 드는 리소스 등을 오버헤드라고 할 수 있다. 
```

> 이렇게 CPU가 프로세스를 바꿔가며 실행하기 위해서 문맥 교환을 통해 여러 개의 프로세스를 동시에 실행하는 것 처럼 만든다.

#### Context Switching이 아닌 경우 ?
<img width="100%" alt="image" src="https://user-images.githubusercontent.com/98382954/227759497-641adac0-8b8f-45f8-8cb8-d783b8927df6.png">

> 문맥교환이 아닌 것과 혼동하지 말자. 문맥교환은 프로세스A에서 프로세스B로 넘어가는것이다.<br>
> System call이나 interrupt 발생시 반드시 context switch가 일어나는 것은 아니다.


1. 문맥교환 X 사용자 프로세스 A -> interrupt or system call -> 커널모드 -> 문맥 교환 없이 user 모드 복귀 -> 사용자 프로세스 A
2. 문맥교환 O 사용자 프로세스 A -> interrupt or I/O 요청 system call -> 커널모드(ISR or system call) -> 문맥 교환 발생 -> 사용자 프로세스 B

- 사용자 모드에서 실행되다가 커널 모드로 실행 모드만 바뀌는 것일 뿐, CPU를 점유하는 프로세스가 다른 사용자 프로세스로 변경괴는 과정이 아니기 때문이다.
  - (1)의 경우에도 CPU 수행 정보 등 context의 일부를 PCB에 save해야 하지만 문맥교환을 하는 (2)의 경우 그 부담이 훨씬 크다.
- 타이머 인터럽트가 발생하거나 프로세스가 I/O 요청 시스템을 콜하여 봉쇄 상태에 들어가는 경우에는 문맥 교환이 일어나지만, 
  
  그밖의 인터럽트나 시스템 콜 발생 시에는 문맥 교환이 일어나지 않고 모드만 변경된다.
  
  
### Context Switching 절차
<img width="100%" alt="image" src="https://user-images.githubusercontent.com/98382954/227759334-6dc32cf6-79ba-4911-be28-9f3c02704345.png">

| 단계 | 절차 | 설명 |
| :--: | :--: | :--: |
| 1 | 인터럽트 / 시스템 호출 | 운영체제에서 프로세스 스케줄러에 의해 인터럽트 발생 |
| 2 | 커널 모드 전환 | 프로세스가 실행되는 사용자 모드에서 커널 모드로 전환 |
| 3 | 현재 프로세스 상태 PCB 저장 | 기존 실행되는 프로세스 정보를 PCB에 저장 |
| 4 | 다음 실행 프로세스 로드 | PCB에 있는 다음 실행 프로세스 상태 정보 복구 |
| 5 | 사용자 모드 전환 | 커널 모드에서 사용자 모드로 전환하여 프로세스 실행 |

#### Context Switching Overhead 해결 방안

| 해결 방안 | 설명 | 
| :--: | :--: | 
| 프로그램 다중화 수준 낮춤 | 다중 프로그래밍 수준을 낮추어 문맥 교환 발생 빈도 감소 |
| 스레드 이용 | Light Weight 프로세스인 스레드를 이용하여 문맥 교환 부하 최소화 | 
| 스택 포인터 활용 | 스택 이용 프로그램의 경우 스택 포인터를 이용하여 문맥 교환 부하 최소화 |


#### Reference
<https://junsangkwon.tistory.com/45><br>
<https://aktnfl.tistory.com/25><br>

### Process와 Thread를 이해해야 하는 이유?
- 스프링은 MultiProcess 환경에서 동작하고 스프링 빈은 기본적으로 싱글톤환경에서 구성되는데 이때 Thread-Safe하게 기능하기 위해선 상태값을 

  상태값을 갖지 않는 형태의 불변객체를 통한 싱글톤 형태로 만들게 되는데 이때 설계 원리 , 내부 동작을 이해하기 위해선 Process와 Thread를
  
  이해하고 있어야 하며 이것들을 이해하고 있어야 나중에 맞닦뜨릴 수많은 문제들을 해결 , 개선할 수 있기 때문이다.
  
#### Program vs Process vs Processer
`Program`
  - 파일이 저장 장치에 저장되어 있지만 메모리에는 올라가 있지 않은 정적인 상태를 말한다.
    - 아직 운영체제가 프로그램에게 독립적인 메모리 공간을 할당해주지 않는 것을 의미하며 모든 프로그램은 운영체제가 실행되기 위한  
    
      메모리 공간을 할당해 줘야 실행될 수 있다.
      
    - 정적인 상태라는 것은 말 그대로 실행되지 않는 다는 것을 의미하는 것이다. 


`Process`
  - 실행되고 있는 컴퓨터 프로그램이라고 정의를 내리기도 하며 스케줄링 단계에서의 "작업"과 같은 단어라고 봐도 무방하다.
  - 메모리에 올라와 실행되고 있는 프로그램의 인스턴스(독립적인 개체)
  - 운영체제로부터 시스템 자원을 할당받는 작업의 단위를 의미한다.
 

`Processer`
  - 프로세스가 동작될 수 있도록 하는 하드웨어(=CPU)이다.
    - 동작: 프로그램의 자원들이 메모리에 올라오고, 실행되어야 할 코드의 메모리 주소를 CPU의 레지스터로 올리는 것 
 <img width="100%" alt="image" src="https://user-images.githubusercontent.com/98382954/215337938-03531ea7-860d-4851-90a7-452628bb437e.png">


### Process란?
- 프로세스는 기본적으로 1개의 쓰레드(메인 쓰레드)를 갖고 있다. 
- 각 프로세스는 별도의 주소 공간에서 실행되며, 한 프로세스는 다른 프로세스의 변수나 자료구조에 접근할 수 없다.
- 한 프로세스가 다른 프로세스의 자원에 접근하려면 프로세스 간의 통신(IPC, inter-process communication)을 사용해야 한다
  - 파이프 , 소켓등을 이용한 방법들이 존재한다.

#### Process의 메모리 구조
<img width="100%" alt="image" src="https://user-images.githubusercontent.com/98382954/215337236-ce62a2a6-dfb4-4f8c-a78c-eec6603b9b4d.png">

- 사진처럼 프로세스는 프로그램이 실행될 때마다 각각 독립된 메모리 영역(Code, Data, Stack, Heap의 구조)을 할당받는다.
  - 여기서 Data의 영역은 다시 초기화 되지 않은 데이터(bss)와 초기화된 데이터 2개의 영역으로 구분지을 수 있다.

`Stack`
  - 지역변수 , 매개변수와 같은 임시 데이터들이 저장되는 공간이다.
  - 컴파일 시점에 크기가 할당되며 무한하게 할당받을 수 없기 때문에 Stack영역을 초과하거나 잘못된 주소로 접근하게 되면 Stack overFlow 에러가 발생한다.
  - 가장 높은주소에 위치하고 있으며 가장 높은 주소부터 낮은 주소로 메모리를 할당받게 된다.

`Heap`
  - 사용자에 의해 관리되는 영역이며 동적으로 동적으로 할당되는 데이터가 저장되는 곳으로 런타임에 크기가 결정된다. 

`Data`
  - Uninitialized data (bss) - 초기화되지 않은 변수(전역 변수, static 변수)가 저장되는 곳이다.
  - Initialized data - 초기화된 변수(전역변수, static 변수)가 저장되는 곳이다.

`Text`
  - 프로그램의 코드가 저장되는 곳이며 컴파일 시점에 메모리가 할당되고 중간에 코드를 수정할 수 없게 Read-Only로 지정돼 있다.

#### Cpu와 프로세스의 처리 방식
```
상단의 사진을 보면 여러 프로세스가 동시에 실행되고 관리 되는 것처럼 보이지만, 사실 CPU는 한번에 한가지 명령어밖에 처리하지 못한다.
즉, 동시가 아닌 재빠르게 프로세스들을 번갈아가며 실행하고, 관리하는 것이다. -> Context Switching(문맥교환)이라 한다.
CPU는 상상이상으로 빠르기 때문에, 프로세스들을 번갈아가며 실행하고 관리하는 것이 마치 동시에 하는 것처럼 보일 뿐이다.
```

#### Thread의 탄생 배경
```
과거 프로그램의 기능들이 단순했을 땐 실행부터 종료까지 프로세스 하나만을 사용했다고 한다.
현재는 프로그램의 기능이 복잡해지고 세분화되어 더 이상 프로세스 하나만을 사용해서 프로그램을 실행하기는 벅차게 되었다.
운영체제는 안정성을 위해 프로세스를 실행함에 있어 독자적인 공간만을 배정하기 때문에 프로세스간 자원을 공유하는 것은 쉽지 않고 자신에게 할당된 메모리만을 
사용하도록 제약이 있기 때문에 이 한계를 해결하기 위해 더 작은 실행단위를 의미하는 쓰레드가 생겨나게 되었다.
```

### Thread란?
   - 스레드는 어떠한 프로그램 내에서, 특히 프로세스 내에서 실행되는 흐름의 단위를 말한다.
   - 하나의 애플리케이션(프로그램)은 하나 이상의 프로세스를 가지고 있고, 하나의 프로세스는 반드시 하나 이상의 스레드를 갖는다.
   - 프로세스의 자원을 할당받아 실행되는 더 작은 실행 단위 개념을 의미한다.

<img width="100%" alt="image" src="https://user-images.githubusercontent.com/98382954/215340100-853bd3ad-47c2-4125-86ca-a2e67e2527ca.png">

- 쓰레드는 프로세스가 할당받은 메모리 영역 내에서 Stack 형식으로 할당된 메모리 영역은 따로 할당받고, 나머지 Code/Data/Heap 형식으로 할당된 

  메모리 영역을 공유한다.
  
- 각각의 스레드는 별도의 레지스터와 스택을 갖고 있지만, 공유하고 있는 공간의 즉 Heap영역의 데이터를 변경시키면 이웃 쓰레드 또한 변경사항을 <br>즉시 반영하게 된다.

<img width="100%" alt="image" src="https://user-images.githubusercontent.com/98382954/215340309-eeea25cd-b345-4714-8872-df9b8900eaf7.png">

- 구글 크롬이 프로세스와 쓰레드를 이해하기 쉬운 대표적 예시인데 크롬 - 프로세스 탭 - 쓰레드 의 형태로 이뤄져있다.

#### Java Thread
- 쓰레드와 비슷한데 쓰레드는 Os가 운영체제의 역할을 한다면 Java Thread는 JVM이 운영체제의 역할을 하게 된다.
- 자바에는 프로세스가 존재하지 않으며 JVM에 의해 스케줄되는 실행 단위 코드 블럭을 자바 스레드라고 부른다.
- 자바쓰레드의 스케쥴링은 전적으로 JVM이 담당하며 하단과 같은 정보 역시 모두 JVM에서 관리하게 된다.
  1. 쓰레드가 몇개 존재하는지
  2. 쓰레드로 실행되는 프로그램의 코드의 메모리 주소는 어디인지
  3. 쓰레드의 상태는 무엇인지
  4. 쓰레드간 우선순위는 어떠한지
> 개발자는 자바 스레드로 작동할 스레드 코드를 작성하고, 스레드 코드가 생명을 가지고 실행을 시작하도록 JVM에 요청하는 일 뿐이다.

### MultiProcess
<img width="100%" alt="image" src="https://user-images.githubusercontent.com/98382954/215341298-9124473f-b6d2-4bba-a875-b2573720af5e.png">

- 하나의 응용프로그램을 여러 개의 프로세스로 구성하여 각 프로세스가 하나의 작업(태스크)을 처리하도록 하는 것이다.

#### MultiProcess의 장단점
`장점`
  1. 안정성이 좋다. 여러개의 자식 프로세스 중 하나에 문제가 발생해도, 다른 자식 프로세스에 영향이 확산되지 않는다
  2. 구현이 비교적 간단하고, 각 프로세스들이 독립적으로 동작하며 자원의 서로 다르게 할당된다.
`단점`
  1. 스케줄링에 따른 Context Switching이 많아지고 그에 따른 오버헤드가 발생한다 -> 성능 저하로 이어지기 쉬움
     - Context Switching 과정에서 캐쉬 메모리 초기화 등 무거운 작업이 진행되고 많은 시간이 소모되는 등의 오버헤드가 발생하게 된다.
     - 프로세스는 각각의 독립된 메모리 영역을 할당받았기 때문에 프로세스 사이에서 공유하는 메모리가 없기때문에 Context Switching가 발생하면 

       캐쉬에 있는 모든 데이터를 모두 리셋하고 다시 캐쉬 정보를 불러와야 한다.
  2. 프로세스간 통신 기법의 어려움(IPC)
     -  프로세스는 각각의 독립된 메모리 영역을 할당받았기 때문에 하나의 프로그램에 속하는 프로세스들 사이의 변수를 공유할 수 없다.

#### 프로세스의 상태
**멀티프로세스에서 프로세스는 실행되면서 아래의 5가지 상태 변화를 겪는다.**

1. `NEW` 
  - 프로세스를 생성하기 위해 프로그램이 보조기억장치에 있는 상태이다.

2. `Ready` 
  - 프로그램이 메인 메모리에 적재되어 프로세스가 된 상태이다.

    CPU에 의해 실행되를 기다리고 있는 상태이며 준비 상태에 있는 프로세스들은 큐에서 대기하고 있다.
           
3. `Running` 
  - CPU가 해당 프로세스를 실행한 상태이다. 
4. `Waiting (or Block)`
  - 프로세스가 입출력완료, 시그널 수신 등 어떤 사건(event)을 기다리고 있는 상태를 말합니다.
5. `Terminated`
  - 프로세스가 완전히 종료된 상태입니다.    





#### Reference
<https://gmlwjd9405.github.io/2018/09/14/process-vs-thread.html><br>
<https://yoongrammer.tistory.com/51><br>
<https://st-lab.tistory.com/198><br>
<https://philosopher-chan.tistory.com/1301><br>


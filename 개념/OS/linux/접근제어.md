## 접근제어

### 리소스와 소유권
- 리눅스는 다중 사용자 운영체제로 유닉스로부터 사용자 개념을 물려받았다.
- 각 사용자 계정은 실행 파일, 파일 장치, 기타 리눅스 자산에 접근할 수 있는 사용자 ID와 연결된다.
- 인간과 프로세스 모두 사용자 계정으로 실행할 수 있고 사용자가 이용 가능한 하드웨어, 소프트웨어 구송요소인 리소스(간단히 `파일`)dl dlTek.
  - 시스템 콜과 같이 다른 종류의 리소에 대한 접근을 명시적으로 언급하지 않으면 리소스는 **파일**로 지칭

`사용자`
- 프로세스를 실행하고 파일을 소유, **프로세스**는 커널이 메인 메모리에 로드해 실행하는 일종의 프로그램(실행 파일)이다.

`파일`
- 소유자가 존재하며 기본적으론 파일을 만든 사용자가 파일을 소유

`프로세스`
- 의사소통과 지속성을 위해 파일을 사용, 사용자도 파일을 간접적으로 사용하긴 하지만 그러려면 프로세스를 통해야 한다.

### 샌드박스
- **샌드박스**의 정의는 다소 모호해 제일(jail)에서 컨테이너, 가상 머신에 이르기까지 커널이나 사용자 영역에서 관리할 수 잇는 다양한 방법을 가리킬 수 있다.
- 일반적으로 샌드박스(대부분 어떤 애플리케이션)에서 실행되는 항목이 있다면 감시 매커니즘은 샌드박스 프로세스와 호스팅 환경 간 어느 정도 격리를 시행한다.

### 접근 제어 유형
- 접근 제어의 한 측면은 접근 자체의 특성이다.
- 개념적으론 다양한 접근 제어 유형이 있으나 리눅스 관점에서 중요한 두가지는 `임의 접근 제어`와 `강제 접근 제어`다.

`임의 접근 제어(discretionary access control)`
- 임의 접근 제어(DAC)를 사용하면 사용자 신분을 기반으로 리소스에 대한 접근을 제한할 수 있다.
  - 여기서 임의란 특정 권한을 가진 사용자가 이를 다른 사용자에게 전달할 수 있음을 의미한다.

`강제 접근 제어(mandatory access control)`
- 강제 접근 제어(MAC)는 보안 수준을 나타내는 계층 모델을 기반으로 한다.
- 사용자에겐 허용 등급이 할당되고 리소스엔 보안 레이블이 할당된다.
- 강제 접근 제어 모델에선 관리자가 모든 권한을 설정하여 엄격하고 배타적으로 접근을 제어한다.
  - 사용자는 리소스를 소유해도 권한을 스스로 설정하지 못한다.

> 리눅스는 `전부 아니면 전무(all of nothing)`라는 태도를 견지한다.
>
> 사용자는 모든 것을 변경할 수 있는 슈퍼 유저이거나 접근이 제한된 일반 사용자 중 하나라는 뜻이다.

<details>
<summary><strong>강제 접근 제어 모델</strong></summary>
<div>

**SE리눅스**(https://oreil.ly/HAOBS)는 가장 잘 알려진 리눅스용 강제 접근 제어 구현 모듈이다.
- 정부 기관의 높은 보안 요구사항을 충족하도록 개발됐으며 엄격한 규칙으로 사용이 어려워 제한적으로 사용된다.

버전 2.6.36부터 리눅스 커널에 포함되어 리눅스 배포판의 우분투 제품군에서 널리 사용되는 **앱 아머**도 있다.

</div>
</details>

### 사용자
- 리눅스에선 목적 또는 의도적 사용 관점에서 사용자 계정을 두 가지 유형으로 구별한다.

1. 시스템 사용자 또는 시스템 계정
   - 프로그램(daemon이라고도 함)은 이런 유형의 계정을 사용해 백그라운드 프로세스를 사용한다.
2. 일반 사용자

이 구분은 조직적인 구성에 가까우며 리눅스는 32비트 숫잣값인 사용자 ID(UID)를 사용해 사용자를 식별하며, 사용자는 그룹 ID(GID)를 통해 식별되는 하나 이상의 그룹에 속한다.

<details>
<summary><strong>systemd 기반 배포판의 UID 범위를 결정하는 규칙</strong></summary>
<div>

- UID 0
  - root 사용자
- UID 1~999
  - 시스템 사용자에게 지정
- UID 65534
  - nobody 사용자. NFS와 같이 원격 사용자를 잘 알려진 ID에 매핑하는데 사용
- UID 1000~65533, 65536~4294967294
  - 일반 사용자

```shell
id -u # 자신의 UID를 알아내는 방법
```

</div>
</details>

#### 로컬에서 사용자 관리
- 첫번째 옵션은 사용자를 로컬에서 관리하는 것인데 로컬에 저장된 정보만 사용하며 이를 위해 리눅스는 간단한 파일 기반 인터페이스를 사용한다.

|    목적    |     파일      |
|:--------:|:-----------:|
| 사용자 데이터베이스 | /etc/passwd | 
| 그룹 데이터베이스 | /etc/group |
| 사용자 비밀번호 | /etc/shadow |
| 그룹 비밀번호 | /etc/gshadow |

<details>
<summary><strong>로컬 사용자 관리에 대한 구체적인 예</strong></summary>
<div>

```shell
cat /etc/passwd
root>23:22:12 
root:x:0:0:root:/root:/bin/bash # root 사용자는 UID 0을 가지고 있음
#7    6 5 4 3    2     1
bin:x:1:1:bin:/bin:/sbin/nologin 
daemon:x:2:2:daemon:/sbin:/sbin/nologin # 시스템 계정(nologin이 제공)
```

사용자 항목의 구조를 이해하기 위해 3번째 행의 하단에 있는 4행의 번호별 의미를 살펴본다.
1. /bin/bash : 사용할 로그인 셸, 대화실 로그인을 이용하지 않으려면 /sbin/nologin을 이용해야 한다.
2. /root : 사용자의 홈 디렉토리, 기본값은 /
3. 사용자 정보이며 GECOS(https://oreil.ly/ZWQ0f)필드라고도 알려져있고 이 형식은 잘 사용되지 않지만 

   필드 자체는 연결된 사람의 전체 이름으로 사용된다.
4. 사용자의 기본 그룹(GID), /etc/group도 참조하자
5. UID. 리눅스는 1000미만의 UID는 시스템 사용을 위해 예약해 둔다.
6. 사용자의 비밀번호. x 문자는(암호화된) 비밀번호가 /etc/shadow 에 저장된다.(요즘은 기본값)
7. 사용자 이름은 32자 이하여야 한다.

</div>
</details>

<details>
<summary><strong>사용자 추가와 의미 해석</strong></summary>
<div>

```shell
sudo adduser test
#Adding user 'test' ...
#Adding new group 'test' (1001) ...
#Addind new user 'test' (1000) with group 'test' ...
#Creating home directory '/home/test' adduser 명령은 홈 디렉토리 생성
#Copying files from '/etc/skel' ... 기본 구성 파일을 홈 디렉토리에 복사
```

> 시스템 계정을 생성하려면 -r 옵션을 전달하면 되는데 이 경우 로그인 셸 기능이 비활성화되고 홈 디렉토리 생성도 되지 않는다.

</div>
</details>

#### 중앙집중식 사용자 관리
- 시스템이나 서버가 둘 이상인 경우 중앙에서 사용자를 관리하지만 특정 시스템에 로컬로 적용할 수 있는 관리 방식이 필요하다.

1. 디렉토리 기반
   - LDAP(Lightweight Directory Access Protocol)는 현재 IETF에서 공식화되있으며 IP를 통해 

     분산 디렉토리에 접근해 유지 관리하는 방법을 정의한다.
   - 예를 들어 키클록 같은 프로젝트를 이용해 LDAP 서버를 직접 실행하거나 애저 엑티브 디렉터리 같은 클라우드 제품도 가능하다.
2. 네트워크 이용
   - 커버로스(Kerberos)를 사용하면 네트워크로 사용자를 인증할 수 있다.
3. 구성 관리 시스템 사용
   - Ansible, Chef, Puppet, SaltStack 등 시스템을 사용해 여러 컴퓨터에 일관되게 사용자를 생성할 수 있다.

### 파일 권한
- 파일 권한은 `리소스에 접근`한다는 리눅스 개념의 핵심이며 좁은 범위부터 넓은 범위까지 세가지 유형/범위의 권한이 있다.

1. 사용자
   - 파일의 소유자
2. 그룹
   - 그룹은 하나 이상의 구성원이 있다.
3. 나머지

이 외 세가지의 접근 유형이 존재한다.

1. 읽기(r 십진법으로 4)
   - 일반 파일의 경우 사용자가 파일 내용을 볼 수 있고 디렉터리의 경우 사용자는 디렉터리에 있는 파일의 이름을 볼 수 있다.
2. 쓰기(w 십진법으로 2)
   - 일반 파일의 경우 수정,삭제가 가능하고 디렉토리의 경우 디렉토리에서 파일 생성, 이름 변경, 삭제가 가능하다.
3. 실행(x 십진법으로 1)
   - 위 권한이 있다면 읽기 권한을 가진 경우 이 파일 실행도 가능하며 디렉토리의 경우 파일 정보에 접근할 수 있도록 허용해

     사용자가 디렉터리로 이동(cd)하거나 내용을 나열(ls)할 수 있게 만들어준다.

<details>
<summary><strong>그 외 접근 속성</strong></summary>
<div>

`s`
- 실행 파일에 적용되는 setuid/setgid 권한으로 이를 실행한 사용자는 파일 소유자, 그룹의 유요한 권한을 상속받는다.
`t`
- t는 디렉토리에만 관련된 스티키 비트(sticky bit)로 이 옵션이 설정되면 디렉토리/파일 소유자 외 사용자가 파일을 삭제하지 못하게 방지한다.

</div>
</details>



<details>
<summary><strong>실제 파일 권한 확인</strong></summary>
<div>

```shell
ls -al
# total 0
# -rw-r--r-- 1 test devs 9 Apr 12 11:42 test
# 7          6 5    4    3  2           1
```

1. 파일 이름
2. 마지막으로 수정한 타임스탬프
3. 파일 크기(바이트)
4. 파일이 속한 그룹
5. 파일 소유자
6. 하드링크 개수(https://oreil.ly/9Gfzu)
7. 파일 모드

. rwx rwx rwx

4  3   2   1

1. 나머지 사용자의 권한
2. 그룹의 권한
3. 파일 소유자의 권한
4. 파일의 형식

|     기호     |      의미      |
|:----------:|:------------:|
| - | 일반 파일(예: touch abc를 한 경우처럼) |
| b | 블록 특수 파일 |
| c | 캐릭터 특수 파일 |
| C | 고성능(연속 데이터) 파일 |
| d | 디렉토리 |
| l | 심볼릭 링크 |
| p | 명명된 파이프(mfifo로 생성) | 
| s | 소켓 |
| ? | 기타(알 수 없는) 파일 형식 |

- 권한은 8진법으로 표기하며 664는 파일을 만들때 할당하는 기본 권한이다.

```shell
chmod +x
# 해당 명령은 모든 권한에 대해 실행 권한을 추가한다. 644 -> 755가 되는 형식
chmod 744 # 모든 권한에 대해 추가하고 싶지 않다면 명시적으로 표기하는것이 좋다.
```

</div>
</details>

### 프로세스 권한
- 사용자 관점을 떠나 프로세스 관점에서의 권한을 설명한다.

`RUID`
- RUID(real user ID- 진짜 사용자 ID)는 프로세스를 시작한 사용자 ID 즉 프로세스 소유권을 가진 사용자 ID를 보여준다.
  - 프로세스에선 getuid(2)혹은 셸에서 stat -c "%u %g" /proc/$pid/을 사용해 쿼리도 가능하다.

`EUID`
- 리눅스 커널은 공유 리소스에 접근할 때 EUID(유효 사용자 (effective user) ID)를 사용해 프로세스가 갖는 권한을 결정한다.
- 전통적 유닉스에선 EUID가 파일 접근에도 사용된 반면, 리눅스는 접근 권한에 전용 파일시스템 UID를 사용하는데 이 방법은 하휘호환성으로 지원된다.
  - 프로세스에선 getuid(2)를 통해 EUID를 얻을 수 있다.

`저장된 SUID`
- SUID 맥락에서, 저장된 SUID는 프로세스가 실제 UID와 저장된 SUID사이에서 유효 UID를 전환함으로 권한을 가정할 수 있을때 사용된다.
  - 특정 포트 사용시 root로 실행되는 것처럼 높은 권한이 필요하면 getresuid(2)를 통해 저장된 SUID를 가져올 수 있다.

`FUID(FileSystem UID)`
- FUID는 리눅스 전용 ID로서 파일 접근 권한을 결정하는데 사용됐으며, 파일 서버가 사용자 대신 동작할때 사용자로부터 프로세스를 격리하는 사용 사례를 지원하기 위해 도입됐다.
- 프로그램은 이 UID를 직접 조작하지 않고 커널은 EUID가 변경되는 시기를 추적하고 이에 따라 FUID를 자동으로 변경한다.
- 일반적으로 FUID가 EUID와 동일하다는 반증이지만 setfuid(2)를 통해 변경할 수 있는데 FUID는 커널 v2.0이후로 필요하진 않지만 호환성 때문에 지원된다.

**파일 접근 권한 외 프로세스UID를 사용하는 예**
- 신호를 보내기 위한 권한 설정
  - 특정 프로세스 ID에 대해 kill -9 를 했을때 어떤 일이 발생할지 결정한다.
- 스케줄링과 우선 순위에 대한 권한 처리
- 리소스 제한 확인

### 고급 권한 관리

#### 캐퍼빌리티
- 리눅스에선 root 사용자가 프로세스를 실행할때 아무런 제한이 없으며 커널은 하단의 두 가지 경우만 구분한다.
- 1. EUID가 0(일명 root)인 권한 있는 프로세스는 커널 권한 검사를 우회(bypass)한다.
  2. EUID가 0이 아닌, 권한 없는 프로세스에 대해선 커널이 권한 검사를 수행한다.
- 커널 v2.2에 캐퍼빌리티 시스템 콜이 도입되며 이분법적 세계관으로 바뀌었는데 root와 관련됐던 권한은 개별로 스레드마다 독립적으로 할당할 수 있게 됐다.
- 캐퍼빌리티 없는 프로세스는 앞선 권한으로 제어되는데 프로세스 or 파일에 캐퍼빌리티를 할당해 작업 수행에 필요한 권한을 점진적으로 추가할 수 있다.
- 캐퍼빌리티는 시스템 수준의 작업에만 관련되어 대부분 캐퍼빌리티에 의존하지 않아도 된다.


<details>
<summary><strong>캐퍼빌리티 예</strong></summary>
<div>

|   캐퍼빌리티   |                  의미                  |
|:---------:|:------------------------------------:|
| CAP_CHOWN | 사용자가 파일의 UID/GID를 임의로 변경할 수 있게 허용한다. |
| CAP_KILL | 다른 사용자에게 속한 프로세스에 신호를 보낼 수 있게 허용한다. |
| CAP_SETUID | UID를 변경할 수 있게 허용한다. |
| CAP_SETPCAP | 실행 중인 프로세스의 캐퍼빌리티를 설정할 수 있게 허용한다. |
| CAT_NET_ADMIN | 인터페이스 구성과 같은 다양한 네트워크 관련 작업을 허용한다. |
| CAP_NET_RAW | RAW와 PACKET 소켓의 사용을 허용한다. |
| CAP_SYS_CHROOT | chroot의 호출을 허용한다. |
| CAP_SYS_ADMIN | 파일시스템 마운트를 포함한 시스템 관리 작업을 허용한다. |
| CAP_SYS_PTRACE | strace를 사용하여 프로세스를 디버그할 수 있게 허용한다. |
| CAP_SYS_MODULE | 커널 모듈의 로딩을 허용한다. |

```shell
capsh -- print # 시스템의 모든 캐퍼빌리티의 개요

grep Cap /rpoc/$$/status # 현재 프로세스(셸)의 캐퍼빌리티
```

</div>
</details>

- **getcap**과 **setcap**을 사용하면 캐퍼빌리티를 세분화된, 파일 단위로 관리가 가능해 기존의 권한 방식에서 벗어나 파일 기반의 세분화된 권한으로 전환하는데 도움이 된다.

### seccomp(secure computing mode) 프로필
- 2005년부터 사용될 수 있게된 리눅스 커널 기능이다.
- seccomp(2)라는 전용 시스템 콜을 사용해 프로세스가 사용할 수 있는 시스템 콜을 제한할 수 있다는 것이다.
  - 직접 관리가 불편할 수 있지만 도커와 쿠버네티스 모두 seccomp를 지원한다.

### 접근권한 사용 시 참고사항
1. chmod +x를 지양하고 숫자 표기법을 통한 명시적 권한을 지향하자.
2. 루트 실행을 지양하고 필요하다면 sudo를 사용해야 한다.
3. setuid는 공격자가 시스템을 장악하기에 좋아 지양하고 필요하다면 캐퍼빌리티를 사용하자.
4. 모든 작업을 변조할 수 없는 방식으로 로그에 기록하는 감사를 통해 누가 언제 무엇을 작업했는지 확인하자.


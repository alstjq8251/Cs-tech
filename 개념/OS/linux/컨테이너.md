## 컨테이너

- 컨테이너를 리눅스 네임스페이스, cgroup, 때로 CoW 파일시스템을 사용해 어플리케이션 수준의 종속성 관리를 제공하는 리눅스 프로세스 그룹으로 이해한다.
- 리눅스에서 컨테이너는 새로운 개념은 아니지만 도커 덕분에 2014년부터 주류로 편입되었는데 그전까지 컨테이너를 도입하려던 사례는 하단과 같다.
  - 리눅스 V서버(Linux-VServer)
  - 오픈VZ(OpenVZ)
  - LXC(2008)
  - lmctfy(Let Me Contain That for You)

> 모든 접근 방식의 공통점은 네임스페이스, cgroup같이 리눅스 커널이 제공하는 기본 빌딩 블록을 사용해 사용자가 app을 실행할 수 있게 하는 것이다.

- 도커는 기존 개념을 혁신하고 2가지 획기적인 요소를 도입했다.
    1. 컨테이너 이미지를 통해 패키징을 정의하는 표준적인 방법(Open Container Initiative OCI)
    2. 인간 친화적인 사용자 인터페이스(cli ex: docker run)
- 도커에서 컨테이너 이미지가 정의되고 배포되는 방식과 컨테이너가 실행되는 방식은 현재 OCI 핵심 사양의 기반이 됐다.
- 3가지 핵심 OCI 컨테이너 사양은 하단과 같다.
    1. 런타임 사양
       - 운영과 수명주기 단계를 포함해 런타임이 지원해야 하는 것을 정의한다.
    2. 이미지 형식 사양 
       - 메타데이터와 계층을 기반으로 컨테이너 이미지가 구성되는 방식을 정의한다.
    3. 배포 사양
       - 컨테이너 이미지가 전달되는 방식, 컨테이너와 관련해 저장소가 효과적으로 동작할 수 있는 방식을 정의

- 컨테이너와 관련된 또 다른 개념은 불변성(imutability)인데 한 번 구성 시 런타임간 변경할 수 없다는 의미다.
  - 변경하기 위해선 새로운(정적) 구성과 새 리소스(프로세스)를 생성해야 한다.

### 리눅스 네임 스페이스

- 초기 리눅스는 리소스에 대해 전역 뷰를 가지고 있었는데 프로세스가 리소스(파일시스템, 네트워킹, 사용자)에 대한 로컬 뷰를 가질 수 있도록 네임스페이스를 도입했다.
- 리눅스 네임스페이스는 리소스 가시성에 관한 것이며 운영체제 리소스의 다양한 측면을 격리하는데 사용할 수 있다.
- 네임스페이스 관점에서의 격리란 프로세스가 무엇을 보는지와 관련이 있으며 보안에서의 엄격한 경계는 아니다.
- 네임스페이스르 생성하려면 3가지 관련 시스템 콜을 원하는 대로 상황에 맞게 사용할 수 있다.
    1. clone
        - 실행 컨텍스트의 일부를 부모 프로세스와 공유할 수 있는 자식 프로세스를 만드는 데 사용된다.
    2. unshare
        - 기존 프로세스에서 공유된 실행 컨텍스트를 제거하는 데 사용된다.
    3. setns
        - 기존 프로세스를 기존 네임스페이스에 결합하는데 사용된다.


<details>
<summary><strong>시스템 콜 매개변수(네임스페이스를 세밀하게 제어할 수 있음)</strong></summary>
<div>

- `CLONE_NEWNS`
  - 파일시스템 마운트 지점에 사용한다. 
  - /prod/$PID/mounts를 통해 확인할 수 있으며 리눅스 2.4.19부터 지원된다.
- `CLONE_NEWUTS`
  - 호스트명과 (NIS) 도메인 이름 격리를 만들 때 사용한다.
  - uname -n 과 hostname -f 를 통해 확인할 수 있으며 리눅스 2.6.19부터 지원된다.
- `CLONE_NEWIPC`
  - 시스템V IPC 객체나 POSIX 메시지 큐 같은 프로세스간 통신(IPC)의 리소스 격리를 할 때 사용한다.
  - /proc/sys/fs/mqueue, /proc/sys/kernel, /proc/sysvipc를 통해 확인할 수 있고 리눅스 2.6.19부터 지원된다.
- `CLONE_NEWPID`
  - PID 번호 공간 격리를 할 때 사용한다. 
  - /proc/$PID/status를 통해 세부 정보를 수집할 수 있으며 리눅스 2.6.24부터 지원된다.
- `CLONE_NEWNET`
  - 네트워크 디바이스, IP 주소, IP 라우팅 테이블, 포트 번호 같은 네트워크 시스템 리소스의 가시성을 제어하는 데 사용한다.
  - ip netns list, /proc/net, /sys/class/net을 통해 확인할 수 있고 리눅스 2.6.29부터 지원된다.
- `CLONE_NEWUSER`
  - 네임스페이스 내부/외부에서 UID+GID를 매핑하는 데 사용한다.
  - id 명령과 /proc/$PID/uid_map, /proc/$PID/gid_map을 통해 UID,GID 그리고 해당 매핑을 조회할 수 있고 리눅스 3.8부터 지원
- `CLONE_NEWGROUP`
  - 네임스페이스에서 cgroup을 관리하는 데 사용한다..
  - /sys/fs/cgroup, /proc/cgroup, /proc/$PID/cgroup을 통해 확인할 수 있으며 리눅스 4.6부터 지원한다.

```shell

$ sudo lsns # 시스템에서 사용 중인 네임스페이스를 보는 방법
        NS TYPE  NPROCS   PID USER      COMMAND
4026531836 pid      424     1 root      /usr/lib/systemd/systemd --switched-root
4026531837 user     861     1 root      /usr/lib/systemd/systemd --switched-root
4026531838 uts      424     1 root      /usr/lib/systemd/systemd --switched-root
4026531839 ipc      424     1 root      /usr/lib/systemd/systemd --switched-root
```

</div>
</details>

### 리눅스 cgroup

- 네임스페이스가 가시성이라면 cgroup은 프로세스 그룹을 구성하는 매커니즘이다.
- cgroup을 계층 구조와 함께 사용하면 시스템 리소스 사용을 제어할 수 있고 리소스 사용 추적을 할 수 있다.
- cgroup은 선언형 유닛으로, 컨트롤러는 특정 리소스 제한을 적용하거나 사용량 보고하는 커널이라고 할 수 있다.
- cgroup은 v1,v2 두 버전이 있고 현재 v1이 널리 이용되고 있지만 미래엔 v2가 v1을 대체할 것으로 보인다.


#### cgroup v1

- cgroup v1을 이용하면 필요시 새로운 cgroup과 컨트롤러를 추가 할 수 있는 애드홉 접근 방식을 사용할 수 있다.
- v1 cgroup과 컨트롤러는 하단과 같다.
  - `CFS 대역폭 제어`
    - cpu cgroup을 통해 사용되며 리눅스 2.6.24부터 지원된다.
  - `CPU 사용량 정산 컨트롤러`
    - cpuacct cgroup을 통해 사용되며 리눅스 2.6.24부터 지원된다.
  - `cpusets cgroup`
    - 작업에 CPU와 메모리를 할당할 수 있으며 리눅스 2.6.24부터 지원된다.
  - `메모리 리소스 컨트롤러`
    - 작업의 메모리 동작을 분리할 수 있고 리눅스 2.6.25부터 지원된다.
  - `디바이스 화이트리스트 컨트롤러`
    - 디바이스 파일 사용을 제어할 수 있다. 리눅스 2.6.26부터 지원된다.
  - `freezer cgroup`
    - 배치 작업 관리에 사용되며 리눅스 2.6.28부터 지원된다.
  - `네트워크 분류기 cgroup`
    - 패킷에 다른 우선 순위를 할당하는 데 사용되며 리눅스 2.6.29부터 지원된다.
  - `블록 I/O 컨트롤러`
    - 블록 I/O를 조절할 수 있다. 리눅스 2.6.33부터 지원된다.
  - `perf_event 명령`
    - 성능 데이터를 수집할 수 있다. 리눅스 2.6.39부터 지원된다.
  - `네트워크 우선순위 cgroup`
    - 네트워크 트래픽의 우선 순위를 동적으로 설정할 수 있다. 리눅스 3.3부터 지원된다.
  - `HugeTLB 컨트롤러`
    - HugeTLB 사용을 제한할 수 있다. 리눅스 3.5부터 지원된다.
  - `프로세스 번호 컨트롤러`
    - 특정 제한에 도달한 후 cgroup 계층이 새 프로세스 생성을 중지시킬 때 사용된다. 리눅스 4.3부터 지원된다.

#### cgroup v2

- cgroup v2는 v1의 피드백을 바탕으로 cgroup을 재작성한 것이다.
- 프로세스별 구분되는 cgroup v1 설계와 달리 cgroup v2는 단일 계층 구조만 가지며 모든 컨트롤러가 동일한 방식으로 관리된다.
- v2 컨트롤러
  - `CPU 컨트롤러`
    - CPU 주기의 분산을 제어한다. 다양한 모델(weight, max)을 지원하고 사용량 보고를 포함한다.
  - `메모리 컨트롤러`
    - 사용자 공간 메모리, 덴트리와 아이노드 같은 커널 데이터 구조, TCP 소켓 버퍼를 지원하는 다양한 제어 매개변수로 메모리 변수를 제어한다.
  - `I/O 컨트롤러`
    - 가중치 기반과 절대 대역폭, 혹은 IOPS(초당 I/O 작업)제한으로 I/O 리소스의 분산을 제어하고 바이트와 IOPS 읽기/쓰기에 대해 보고한다.
  - `프로세스 번호(PID) 컨트롤러`
  - `cpuset 컨트롤러`
  - `HugeTLB 컨트롤러`
    - 위 3가지 컨트롤러는 v1버전과 유사하다
  - `device 컨트롤러`
    - eBPF 위에 구현된 디바이스 파일에 대한 접근을 관리한다.
  - `rdma 컨트롤러`
    - RDMA(remote direct memory access) 리소스의 분산과 연산을 제어한다.
- v2엔 스칼라 리소스(다른 cgroup 리소스 처럼 추상화 불가)에 대해 리소스 제한과 추적 매커니즘을 허용하는 기타 cgroup이 있다.

#### 쓰기 시 복사(CoW) 파일 시스템

- 컨테이너의 세 번째 빌딩 블록은 쓰기 시 복사 파일시스템으로 빌드 시 사용되며 어플리케이션과 모등 종속성을 배포 가능한 독립 파일 하나로 패키징한다.
- CoW 파일시스템은 주로 바인드 마운트(bind mount)와 함께 사용돼 종속성이 서로 다른 컨텐츠를 효율적인 방식으로 계층화한다.

### 도커

- 도커의 독특한 점은 빌딩 블록(네임스페이스, cgroup, CoW 파일시스템, 바인드 마운트 같은)이 아니다.
- 이런 요소는 기존에도 존재하는데 빌딩 블록을 결합할 때 네임스페이스와 cgroup 같은 저 수준 비트 관리의 복잡성을 숨겨 사용하기 쉽게 만드는 방식을 썻다는 점에 있다.

`image`
- 실질적 디렉토리인 JSON 파일과 계층의 메타데이터를 포함하는 압축된 아카이브 파일이다.

### 타 컨테이너 도구

- OCI 컨테이너 작업을 위해 도커를 사용할 필요는 없으며 레드햇이 후원하는 포드맨과 빌다를 대안으로 사용도 가능하다.
- 데몬이 없는 도구를 사용해도 OCI 컨테이너 이미지를 빌드(buildah), 실행(podman)할 수 있다.
- OCI 컨테이너, 네임스페이스, cgroup 작업을 쉽게 해주는 도구는 하단과 같다.
  - `containerd`
    - 이미지 전송과 저장에서부터 컨테이너 런타임 감시까지, OCI 컨테이너 수명주기를 관리하는 데몬
  - `skopeo`
    - 컨테이너 이미지 조작을 위해 사용(복사, 메니페스트 검사 등)
  - `systemd-cgtop`
    - cgroup을 인식하는 top의 변종이며 리소스 사용량을 대화식으로 보여준다.
  - `nsenter`
    - 지정된 기존 네임스페이스에서 프로그램을 실행할 수 있다.
  - `unshare`
    - 특정 네임스페이스로 프로그램을 실행할 수 있다.(플래그를 통해 설정(혹은 등록)할 수 있다.)
  - `lsns`
    - 리눅스 네임스페이스에 대한 정보를 나열한다.
  - `cinf`
    - 프로세스 ID와 관련된 리눅스 네임스페이스와 cgroup에 대한 정보를 나열한다.

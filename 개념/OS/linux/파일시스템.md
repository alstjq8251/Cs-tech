## 파일시스템
- 리눅스 리소스의 대부분은 실제로 파일이며 디바이스와 의사 디바이스 또한 리눅스에선 파일로 취급된다.
- 모든 것이 공통적으로 지니는 점은 파일 열기, 정보 수집, 파일 작성 등 표준화되고 통일화된 인터페이스다.
  -  통일된 인터페이스는 인지 부하를 줄여 리눅스 사용 방법을 더 빠르게 배울 수 있다.
- 리눅스에선 파일시스템이 이런 통일된 인터페이스를 제공하고 리눅스가 파일을 바이트 스트림으로 취급하여 다양한 파일 유형을 지원하는 도구를 만들 수 있게 된다.

`개요`
- 예외가 있긴 하지만 대부분의 파일시스템은 계층 구조로 되어있고 사용자는 root(/)로 시작하는 단일 파일시스템 트리를 제공받게 된다.
- 파일시스템 트리엔 디렉토리와 파일이란 두 가지 유형의 객체가 있다. 
  - 디렉토리를 파일을 그룹화 할 수 있는 조직의 단위, 트리 구조에 비유하면 트리의 노드고 파일이나 디렉터리가 트리의 리프가 된다.
- 디렉토리의 내용을 나열(ls)하고 타 디렉토리로 변경(cd)하고 현재 작업 디렉토리를 출력(pwd)하는 등 파일시스템을 탐색할 수 있다.
- 파일시스템이 가지고 있는 속성 중 소유권이 있으며 권한이 내장되어 있고, 소유권은 할당된 권한을 통해 두 객체에 대한 접근을 제어한다.
- 파일시스템은 커널에서 구현된다.

#### 파일시스템을 이해하기 위한 용어
`드라이브`
- 하드 디스크 드라이브(HDD), 솔리드 스테이트 드라이브(SDD)와 같은 블록 디바이스다. 
- 가상 머신의 드라이브는 에뮬레이션될 수 있다.
  - /dev/sda(SCSI 디바이스), /dev/sdb(SATA 디바이스), /dev/hda(IDE 디바이스)

`파티션`
- 드라이브를 스토리지 섹터의 집합인 파티션으로 논리적으로 분할할 수 있다.
  - 예를 들어 HDD에 두개의 파티션을 생성하면 /dev/sdb1 와 /dev/sdb2로 표시되는 식

`볼륨`
- 파티션과 비슷하지만 더 유연하며 특정 파일시스템용으로 포맷되기도 한다.

`슈퍼 블록`
- 시스템이 포맷되면 파일시스템의 시작 부분에 메타데이터를 캡쳐하는 특수 섹션이 생긴다.
  - 파일시스템의 유형, 블록, 상태, 블록당 아이노드 수 등이 담긴다.

`아이노드`
- 크기, 소유자, 날짜, 권한과 같은 메타데이터를 저장하지만 파일명과 실제 데이터는 저장하지 않는다.
  - 위 데이터는 디렉토리에 보관되며 디렉토리는 아이노드를 파일명에 매핑하는 특별한 종류의 일반 파일이라 할 수 있다.

<details>
<summary><strong>용어별 확인하는 방법</strong></summary>
<div>

- 논리 디바이스에 대한 설정을 확인

```shell
lsblk --exclude 7 # 의사(루프) 디바이스를 제외한 모든 블록 디바이스를 나열한다.
NAME   MAJ:MIN RM   SIZE RO TYPE MOUNTPOINT
sda      8:0    0   1.8T  0 disk # 전체적으로 1.8T의 용량을 가진 sda라는 디스크 드라이브가 있다.
└─sda1   8:1    0   1.8T  0 part #
sdb      8:16   1   930G  0 disk # 전체적으로 0.9T의 용량을 가진 sda라는 디스크 드라이브가 있다.
├─sdb1   8:17   1   976M  0 part /boot # 다섯개의 파티션이 존재하며 sdb1은 부팅 파티션이다.
├─sdb2   8:18   1   7.6G  0 part
├─sdb3   8:19   1   7.6G  0 part /tmp
├─sdb4   8:20   1     1K  0 part
└─sdb5   8:21   1 913.8G  0 part /
```

- 사용 중인 파일시스템을 확인 

```shell
findmnt -D -t nosquashfs # 파일시스템을 나열하지만 스쿼시FS(CD용으로 특수 읽기 전용 압축 시스템) 유형은 제외한다.
SOURCE               FSTYPE     SIZE   USED  AVAIL USE% TARGET
devtmpfs             devtmpfs  31.4G      0  31.4G   0% /dev
tmpfs                tmpfs     31.5G      0  31.5G   0% /dev/shm
tmpfs                tmpfs     31.5G   3.2G  28.3G  10% /run
tmpfs                tmpfs     31.5G      0  31.5G   0% /sys/fs/cgroup
/dev/sdb5            ext4     899.3G   332G 521.7G  37% /
/dev/sdb1            ext4     944.7M   187M 692.9M  20% /boot
/dev/sdb3            ext4       7.4G 180.3M   6.8G   2% /tmp
```

```shell
stat myfile
  File: myfile
  Size: 4096      	Blocks: 8          IO Block: 4096   디렉토리 # 파일 유형 정보
Device: 815h/2069d	Inode: 36306979    Links: 2 # 디바이스와 아이노드 정보
Access: (0744/drwxr--r--)  Uid: ( 1005/   test)   Gid: ( 1005/   test)
Access: 2024-10-10 02:45:11.043450892 +0900
Modify: 2023-08-10 13:48:44.359250188 +0900
Change: 2023-08-10 13:48:44.359250188 +0900
 Birth: -
```

|      명령어       |     사용 예제     |
|:--------------:|:-------------:|
| lsblk | 모든 블록 디바이스 나열  |
| fdisk, parted | 디스크 파티션 관리 |
| blkid | UUID와 같은 블록 디바이스 속성 표시 |
| hwinfo | 하드웨어 정보 표시 |
| file -s | 파일시스템과 파티션 정보 표시 |
| stat, df -i, ls -i | 아이노드와 관련된 정보 표시 및 목록 출력 |

</div>
</details>

`링크`
- 다른 이름의 파일을 참조하거나 단축어를 제공하고 싶을때 리눅스에선 두 가지 유형의 링크를 제공한다.

`하드 링크`
- 아이노드를 참조하며 디렉토리는 참조할 수 없고 파일시스템이 다르면 동작하지 않는다.
`심볼릭 링크(symbolic) 또는 Symlink`
- 파일의 내용이 다른 파일의 경로를 나타내는 문자열인 특수 파일

<details>
<summary><strong>실제 링크 예시</strong></summary>
<div>

```shell
ln myfile somealias # 하드 링크 생성
ln -s myfile somesoftalias # 심볼릭 링크 생성(-s옵션)
ls -al *alias # 파일 목록 출력 파일 유형의 차이와 이름 표시 방식을 보자, ls -ali *alis를 사용하면 두 아이노드가 동일하다는 것을 알 수 있다.
stat somealias # 하드링크의 파일 내역 표시
stat somesoftalias # 심볼릭링크의 파일 내역 표시
```

</div>
</details>

### 가상 파일시스템(VFS)
- 리눅스는 가상 파일 시스템(VFS)이란 추상화를 통해 다양한 종류의 리소스(인메모리,로컬 연결, 네트워크 스토리지)에 파일과 유사한 접근을 제시할 수 있다.
- 기본 개념은 클라이언트(시스템 콜)와 개별 파일 시스템 간 간접 계층을 두는 것 이다.
- 개별 파일 시스템은 구체적인 디바이스 또는 다른 리소스 유형을 위한 연산을 구현한다. 즉 VFS는 일반 작업(열기,읽기,찾기)을 실제 구현 세부사항과 분리한다.
- VFS는 파일 체계를 기반으로 클라이언트가 동일한 방법으로 리소스에 접근할 수 있게 해주는 커널의 추상화 계층이다.
- 대표적으로 OOP 개념이 적용된 서브시스템이다

### VFS의 개요

`VFS 시스템 콜`
- VFS의 구성을 몇 가지의 카테고리로 그룹화 할 수 있다.

| 카테고리 | 시스템 콜 예시 |
| :--: | :--: |
| 아이노드 | chmod, chown, stat |
| 파일 | open, close, seek, truncate, read, write |
| 디렉터리 | chdir, getcwd, link, unlink, rename, symlink |
| 파일시스템 | mount, flush, chroot |
| 그 외 | mmap, poll, sync, flock |

다양한 VFS 시스템 콜이 파일시스템 구현으로 보내지고 그 밖의 시스템 콜은 VFS의 기본 구현으로 전달된다.

**리눅스 커널은 관련 VFS 데이터 구조를 하단과 같이 정의한다.**

- inode
  - 핵심 파일시스템 객체, 캡처 유형, 소유권, 권한, 링크, 파일 데이터를 포함하는 블록에 대한 포인터, 생성과 접근 통계 등
- file
  - 열려 있는 파일을 나타냄(경로, 현재 위치와 아이노드 포함)
- dentry(디렉터리 항목)
  - 부모와 자식 저장
- super_block
  - 마운트 정보를 포함한 파일시스템을 나타냄
- 그 외 
  - vfsmount와 file_system_type 포함

### 논리 볼륨 관리자

`개요`
- 파티션을 통해 드라이브를 분할하는 방법은 가능하지만 파티션은 특히(저장 공간 양을 변경하기 위한)크기 조정이 필요할때 사용하기 어렵다.
- 논리 볼륨 관리자(logical volume manager LVM)은 파일 시스템과 물리 개체간의 간접 계층을 사용한다.
- 이를 사용했을 때 리소스 풀링을 통해 위험이 없고 중단 시간도 없는 확장과 자동 스토리지 증설이 가능해진다.

`논리 볼륨 관리자의 속성`
- 물리 볼륨(PV)
  - 디스크 파티션, 전체 디스크 드라이브, 기타 디바이스 등이 있다.
- 논리 볼륨(LV)
  - 볼륨 그룹(VG)에서 생성된 블록 디바이스며 개념적으로 파티션과 비슷하다.
  - 논리 볼륨을 사용하려면 논리 볼륨에 파일시스템을 생성해야 하고 사용 중 크기를 쉽게 조정할 수 있다.
- 볼륨 그룹(VG)
  - 물리 볼륨과 논리 볼륨 사이의 중개자.
  - 볼륨 그룹이란 공동으로 리소스를 제공하는 물리 볼륨 풀이라고 생각

<details>
<summary><strong>LVM 관리 도구</strong></summary>
<div>
  
  - PV 관리 도구
    - lvmdiskscan
    - pvdisplay
    - pvcreate
    - pvscan
  - 볼륨 그룹 관리 도구
    - vgs
    - vgdisplay
    - vgcreate
    - vgextend
  - 논리 볼륨 관리 도구
    - lvs
    - lvscan
    - lvcreate


</div>
</details>

### 파일시스템을 사용하려면?
1. 파일시스템을 생성(리눅스 외 os에선 포맷이라고도 부름)
- 파티션이나 볼륨을 입력 받아 파일시스템으로 구성하는 관리적인 부분을 설정해야 한다는 의미
- 파일 시스템 유형과 파일시스템을 생성하려는 디바이스(논리 볼륨)라는 두가지 기본 입력 정보와 mkfs를 사용해 파일시스템을 생성한다.
- ex) mkfs -t ext4 \ /dev/some_vg/some_lv 
  1. ext4유형의 파일시스템 생성, 
  2. 논리 볼륨 /dev/some_vg/some_lg에 파일시스템 생성
2. 생성된 파일시스템을 마운트 = 파일시스템 트리에 삽입
- 파일시스템을 마운트한다는 의미는 파일시스템 트리에 이를 연결함을 의미하고 mount명령으로 연결한다.
- mount는 두가지 주 입력값을 받는데 연결하려는 디바이스와 파일시스템 트리 내의 위치다.
  - 추가적인 옵션은 읽기 전용(-o)과 디렉터리를 마운트 하기 위한 바인트 마운트(--bind)등이 사용 가능하다.
  - -a로 모든 파일시스템 유형에 대해 마운트가 작동할때 까지 테스트가 가능하다.
  - mount는 실행간에만 유효하므로 영규적으로 유지하려면 fstab 파일을 사용해야 한다.

### VFS의 의의
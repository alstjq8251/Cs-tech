### JPA란?
- Java Persistance Api의 약자이다.
- java진영에서 쓰이는 ORM 기술에대한 API 표준 명세를 의미한다.

### ORM이란?
- `Object Relational Mapping`의 약자로서 객체와 관계형 데이터베이스간의 패러다임 불일치 문제를 해결하는 기술을 의미한다.

> java진영뿐만아니라 백엔드 진영에서 사용하는 언어 및 프레임워크는 각각 객체를 해당 언어로 처리하는데 RDBMS를 처리하는 쿼리는 sql문법으로 <br>작성해야 한다. <br>패러다임의 불일치란 각 프레임워크 혹 언어에서 쓰이는 객체를 영속(영구히 존재)하게 하기 위해선 sql문법을 따로 작성해야 하는 점을 의미하는 것이다.

#### ORM의 의의?
- `ORM`이란 기술이 없었을 땐 개발자는 기능을 작성하는 코드는 물론 sql을 작성해 따로 쿼리를 작성해야만 개발을 할 수 있었다.
  - sql문법은 과거나 현재에도 꾸준히 학습해야 하는 문법임은 맞지만 코드 따로 쿼리 따로 작성하여 테스트를 하는 것은 `생산성` , `유지보수성`이 떨어진다.
    - 기능을 테스트 하기 위해선 코드가 완벽해야 할 뿐 아니라 사전작업등 객체와 db의 정보를 생각해가며 쿼리를 정확하게 작성해 날려야만 가능했기 때문이다.
    - 기능의 동작 여부를 코드를 판단한 이후에도 쿼리가 정상적인 쿼리인지 뜯어보고 런타임에서 에러 , 수정사항을 확인하는 건 개발자들이 개발에 집중할 수 없게 만드는 요인이었다.
- 요청사항에 따라 반영하며 개발해야하는 코드 외 객체와db를 매핑해주는 기술이 있으면 개발 , 유지보수에 필요한 사전작업에 쓰이는 집중도를 최소화 할 수 있다.

> `ORM`이후 개발자들은 더 이상 비효율적인 쿼리를 작성하지 않아도 되며 데이터 중심적인 개발에서 직관적인 코드와 객체로 코드를 작성할 수 있어 객체 지향적인 개발을 지향할 수 있게 되었다.

#### 표준 명세로서의 JPA?
- JPA는 특정 기능을 하는 라이브러리가 아니고, ORM을 사용하기 위한 인터페이스를 모아둔 것이다.
  - JPA는 자바 어플리케이션에서 관계형 데이터베이스를 어떻게 사용해야 하는지를 정의하는 방법중 한 가지이다.
    - JPA외 Mabatis ibatis등 다양한 방법이 존재한다.
  - JPA는 단순 명세이기 때문에 구현체가 존재하지 않는다.
    - hibernate , EclipseLink , DataNucleus등이 존재한다.
    
![image](https://user-images.githubusercontent.com/98382954/210589038-d80259b0-49ee-44db-85b5-95a656d829b2.png)

  - JPA를 정의한 javax.persistence 패키지의 대부분은 interface , enum , Exception, 그리고  Annotation 들로 이루어져 있다.
  - JPA를 이루는 핵심 `EntityManager`또한 javax.persistence 패키지 안에 interface 로 정의되어 있다.
    - 추후 기술할 EntityManger는 영속성 컨텍스트를 내부에 두어 Entity의 생명주기 및 영속성을 관리한다.
 
#### JPA의 구현체는?
- `Hibernate`
- `EclipseLink` ~~추후기술~~
- `DataNucleus` ~~추후기술~~

#### Mibatis등 다른 기술들과 달리 JPA를 사용하는 이유?
~~추후기술~~

#### JPA에서 Hibernate를 쓰는 이유?
- JPA를 구현한 구현체중 가장 성숙한 구현체다.

#### JPA의 장단점
**장점**
1. `생산성`
  - sql을 직접 작성하지 않고 직관적인 코드(메소드)를 호출하여 데이터를 처리할 수 있게 되었다.
  - 반복적인 sql작업을 할 필요성이 사라지는등 생산성을 극대화 시킨다.
2. `유지보수성`
  - Entity의 컬럼과 테이블명을 비교하여 컬럼이 변경되었을 경우 바로바로 반영하여 즉시 JPA에서 처리하여 반영시켜준다
3. `DB종속성`
  - Mabatis등 다른 sql매퍼들의 경우 특정 db에 따라 문법이 바뀌는 경우가 비일비재하여 db를 바꾸는 경우 쿼리를 모두 변경 시켜야 하나 jpa에선 설정파일을 바꾸는 것만으로 db에 맞춰 쿼리를 변경시켜 날려준다.  

**단점**
1. `성능`
  - sql을 직접 작성하지 않는 편리함은 분명 장점이지만 내부적으로 매핑해서 작성되는 쿼리는 성능을 최적화시킨 쿼리라고 보기 어렵다.
    - 따라서 작성되는 쿼리를 스크립트로 봐서 쿼리를 튜닝하거나 db단에 들어가는 쿼리를 확인하지 않으면 그 쿼리가 성능을 저하시킬 수 있음을 인지해야 한다.
 2. `위험성`
  - jpa는 분명 전략(create,create-drop)등에 따라 테이블을 생성시키거나 컬럼을 변경시켜주는 등 매핑정보에 따라 편리하게 만들어주긴 하지만

    이것은 컬럼의 변경사항이 생기거나 매핑정보가 잘못됐을때 바로 테이블의 update쿼리등 쿼리가 날아가 테이블의 변경사항이 생긴다는것을 의미한다.
    - 또한 create등의 전략은 테이블을 다운시킬 수 있으며 실무에선 보통 validate,none을 사용하지만 그마저도 거의 none을 사용한다.
    - 이유는 update또한 변경되는 내용을 바로 반영시키는 위험성과 컬럼을 제거하는등의 역할을 못하기에 제외하고 validate는 entity와 db내용의 정합성만 판별해주기 때문이다.
    - none전략은 전략을 안쓰는것을 의미하는데 사실상 쿼리 스크립트를 보고 각 서비스에 맞춰 테이블을 만드는 쿼리를 작성해 만드는게 실무에 적합하다.
3. `난이도`
  - jpa는 내부적으로 JDBC Api를 사용하여 db와 커넥션을 맺고 데이터를 가져오게 되는데 이러한 내부 동작 , JPA가 성능 향상을 꾀하는 원리등을 이해하는것은 쉽지 않다.
    - 논리적인 형태로 존재하는 영속성 컨텍스트 , 영속성 ,  DB를 지원하는 쓰기지연 저장소 역할도 이해해야 하며 때로는 jpa가 JDBC Api를 통해 쿼리를  
  
      만드는 과정과 그를 통해 어떻게 통신하게 되는지를 이해하고 쓰지 못한다면 쿼리를 작성해주는 편리함에 취해 성능 , 기댓값과 다른 결과를 만들어 <br>낼 수 있다.
      
> JPA와 Spring Data JPA는 다르다 JPA는 표준 명세이며 Spring Data Jpa는 jpa를 편하게 쓰기 위한 프레임워크이니 혼동하지 말아야 한다.
      
#### JPA 내부 동작 방식(영속성)
- JPA가 JDBC Api를 이용하여 쿼리를 작성하는 것 외로 내부적인 영속성 컨텍스트등을 통해 어떻게 동작하는지 성능향상 , 저하가 어떻게 일어나는지 기술한다.

**용어**

`영속성 컨텍스트`
`영속성`

1.`영속성`
- 일반적으로 객체는 스프링이나 우리가 사용하는 프로그램 외부에서 존재, 유지하질 못한다.
  - 따라서 객체는 db등 외부 저장소에 프로그램이 종료되어도 존재하게 하려고 하며 그것을 영속화 한다고 하고 해당 데이터가 가지는 특성을 `영속성`이라고 칭한다.
  - JPA에선 영속성 컨텍스트 내에서 객체가 관리되는 상태를 의미한다.
    - `비영속` , `준영속` , `영속` , `삭제` 이렇게 4가지 상태가 존재한다.

2.`영속성 컨텍스트`
